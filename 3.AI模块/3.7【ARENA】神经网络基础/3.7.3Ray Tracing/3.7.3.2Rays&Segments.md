# å°„çº¿å’Œçº¿æ®µ(Rays & Segments)
## ä¸€ç»´å›¾åƒæ¸²æŸ“
åœ¨æˆ‘ä»¬çš„åˆå§‹å‡å®šä¸­,**ç›¸æœº**æ˜¯åŸç‚¹å¤„çš„å•ä¸ªç‚¹,**å±å¹•**æ˜¯x=1å¤„çš„å¹³é¢.

è¿™ä¸ªä¸–ç•Œä¸­çš„**ç‰©ä½“**ç”±ä¸‰è§’å½¢ç»„æˆ,å…¶ä¸­ä¸‰è§’å½¢åœ¨ä¸‰ç»´ç©ºé—´ä¸­è¡¨ç¤ºä¸º3ä¸ªç‚¹(å› æ­¤æ¯ä¸ªä¸‰è§’å½¢ç”±9ä¸ªæµ®ç‚¹å€¼å†³å®š).ä½ å¯ä»¥ç”¨è¶³å¤Ÿå¤šçš„ä¸‰è§’å½¢æ„å»ºä»»ä½•å½¢çŠ¶,ä½ çš„çš®å¡ä¸˜å°†ç”±412ä¸ªä¸‰è§’å½¢ç»„æˆ.

ç›¸æœºå°†å‘å°„ä¸€æ¡æˆ–å¤šæ¡**å…‰çº¿(å°„çº¿)**,æ¯æ¡å°„çº¿ç”±åŸç‚¹å’Œæ–¹å‘ç‚¹è¡¨ç¤º.ä»æ¦‚å¿µä¸Šè®²,å…‰çº¿å°†ä»åŸç‚¹å‘å°„å¹¶æ²¿ç€ç»™å®šæ–¹å‘ä¼ æ’­,ç›´åˆ°ä¸ç‰©ä½“ç›¸äº¤.

æˆ‘ä»¬ç°åœ¨è¿˜æ²¡æœ‰å»ºç«‹äº®åº¦æˆ–è€…é¢œè‰²çš„æ¦‚å¿µ,æ‰€ä»¥ç°åœ¨æˆ‘ä»¬è®¤ä¸º,å¦‚æœä»åŸç‚¹ç©¿è¿‡å±å¹•çš„å…‰çº¿ä¸ç‰©ä½“ç›¸äº¤,å±å¹•ä¸Šçš„åƒç´ åº”è¯¥æ˜¾ç¤ºäº®çš„é¢œè‰²,å¦åˆ™æˆ‘ä»¬çš„å±å¹•åº”è¯¥æ˜¯é»‘çš„.
![](https://cdn.xyxsw.site/1D-Rendering.png)
åœ¨æœ€å¼€å§‹,åœ¨æˆ‘ä»¬çš„`(x, y, z)`ç©ºé—´é‡Œ,æˆ‘ä»¬çš„zè½´è®¾ä¸º0,æ‰€æœ‰çš„ä»»åŠ¡éƒ½åœ¨å‰©ä¸‹ä¸¤ä¸ªç»´åº¦é‡Œè¿›è¡Œ.

### Exercise - å®Œæˆ `make_rays_1d`
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´âšªâšªâšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µğŸ”µğŸ”µâšªâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š10-15åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
</div>

å¡«å……å®Œæˆ`make_rays_1d`å‡½æ•°,ä½¿å¾—å…¶å¯ä»¥ä»åŸç‚¹`(0, 0, 0)`ç”Ÿæˆä¸€ç³»åˆ—å°„çº¿.

åœ¨ä½ çš„å…‰çº¿ä¸Šè°ƒç”¨`render_linear_with_plotly`å¯ä»¥æŠŠä»–ä»¬å±•ç¤ºåœ¨3Då›¾ä¸­.
```python
def make_rays_1d(num_pixels: int, y_limit: float) -> t.Tensor:
    '''
    num_pixels: The number of pixels in the y dimension. Since there is one ray per pixel, this is also the number of rays.
    y_limit: At x=1, the rays should extend from -y_limit to +y_limit, inclusive of both endpoints.

    Returns: shape (num_pixels, num_points=2, num_dim=3) where the num_points dimension contains (origin, direction) and the num_dim dimension contains xyz.

    Example of make_rays_1d(9, 1.0): [
        [[0, 0, 0], [1, -1.0, 0]],
        [[0, 0, 0], [1, -0.75, 0]],
        [[0, 0, 0], [1, -0.5, 0]],
        ...
        [[0, 0, 0], [1, 0.75, 0]],
        [[0, 0, 0], [1, 1, 0]],
    ]
    '''
    pass

rays1d = make_rays_1d(9, 10.0)

fig = render_lines_with_plotly(rays1d)
```
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    def make_rays_1d(num_pixels: int, y_limit: float) -> t.Tensor:
        '''
        num_pixels: The number of pixels in the y dimension. Since there is one ray per pixel, this is also the number of rays.
        y_limit: At x=1, the rays should extend from -y_limit to +y_limit, inclusive of both endpoints.

        Returns: shape (num_pixels, num_points=2, num_dim=3) where the num_points dimension contains (origin, direction) and the num_dim dimension contains xyz.

        Example of make_rays_1d(9, 1.0): [
            [[0, 0, 0], [1, -1.0, 0]],
            [[0, 0, 0], [1, -0.75, 0]],
            [[0, 0, 0], [1, -0.5, 0]],
            ...
            [[0, 0, 0], [1, 0.75, 0]],
            [[0, 0, 0], [1, 1, 0]],
        ]
        '''
        # SOLUTION
        rays = t.zeros((num_pixels, 2, 3), dtype=t.float32)
        t.linspace(-y_limit, y_limit, num_pixels, out=rays[:, 1, 1])
        rays[:, 1, 0] = 1
        return rays


    rays1d = make_rays_1d(9, 10.0)

</div>
</details>
</div>

### Tip - `out`å‚æ•°
è®¸å¤šPyTorchå‡½æ•°éƒ½æœ‰ä¸€ä¸ªå¯é€‰çš„å‚æ•°`out`.å¦‚æœæä¾›çš„è¯,è¾“å‡ºçš„å¼ é‡å°†ç›´æ¥è¾“å‡ºåˆ°`out`å¼ é‡ä¸Š,è€Œä¸æ˜¯åˆ†é…ä¸€ä¸ªæ–°å¼ é‡å¹¶è¿”å›å®ƒ.

å¦‚æœä½ åœ¨å®Œæˆä¸Šé¢çš„å‡½æ•°çš„æ—¶å€™ä½¿ç”¨äº†`torch.arange`æˆ–è€…`torch.linspace`,è¯•è¯•ç”¨ç”¨`out`å‚æ•°.æ³¨æ„åŸºæœ¬çš„åˆ‡ç‰‡ç´¢å¼•æ–¹å¼ä¾‹å¦‚`rays[:, 1, 1]`è¿”å›äº†ä¸€ä¸ªè§†å›¾(view),å…¶åœ¨å†…å­˜ä¸­å ç”¨çš„ä½ç½®å’Œ`rays`ä¸€è‡´,æ‰€ä»¥å¦‚æœä¿®æ”¹äº†è¿™ä¸ªè§†å›¾çš„å†…å®¹ä¹Ÿä¼šä¿®æ”¹åŸå§‹`rays`çš„å†…å®¹.åœ¨ä»Šå¤©æ™šäº›æ—¶å€™ä½ ä¼šå­¦åˆ°æ›´å¤šå…³äºè§†å›¾çš„å†…å®¹.

## å°„çº¿-ç‰©ä½“äº¤ç‚¹
å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç”±ç«¯ç‚¹$L_1$å’Œ$L_2$å®šä¹‰çš„çº¿æ®µ.é‚£ä¹ˆå¯¹äºä¸€æ¡ç»™å®šçš„å°„çº¿,æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•æ£€æµ‹è¿™æ¡å°„çº¿æ˜¯å¦å’Œçº¿æ®µäº¤å‰:
- å‡è®¾å°„çº¿å’Œçº¿æ®µéƒ½æ˜¯æ— é™é•¿çš„,è§£å‡ºä»–ä»¬çš„äº¤ç‚¹.
- å¦‚æœè¿™ä¸ªäº¤ç‚¹å­˜åœ¨,æ£€æŸ¥è¿™ä¸ªäº¤ç‚¹æ˜¯å¦åŒæ—¶åœ¨å°„çº¿å’Œçº¿æ®µä¸Š.

æˆ‘ä»¬çš„ç›¸æœºå°„çº¿ç”±åŸç‚¹$O$å’Œæ–¹å‘å‘é‡$D$å®šä¹‰,æˆ‘ä»¬çš„ç‰©ä½“çº¿æ®µç”±ç«¯ç‚¹$L_1$å’Œ$L_2$å®šä¹‰.

æˆ‘ä»¬å¯ä»¥å°†ç›¸æœºå°„çº¿ä¸Šæ‰€æœ‰ç‚¹çš„æ–¹ç¨‹å†™ä¸º$R(u)=O+uD$,å…¶ä¸­$u\in[0,\infin)$;ç‰©ä½“çº¿æ®µä¸Šæ‰€æœ‰ç‚¹çš„æ–¹ç¨‹å†™ä¸º$O(v)=L_1 + v(L_2-L_1)$,å…¶ä¸­$v\in[0,1]$.

ä¸‹é¢çš„äº¤äº’å¼å°ç¨‹åºå¯ä»¥è®©ä½ åœ¨å¤„ç†é—®é¢˜çš„æ—¶å€™å‚æ•°åŒ–.è¿è¡Œä»¥ä¸‹å•å…ƒæ ¼:
```python
fig = setup_widget_fig_ray()
display(fig)

@interact
def response(seed=(0, 10, 1), v=(-2.0, 2.0, 0.01)):
    t.manual_seed(seed)
    L_1, L_2 = t.rand(2, 2)
    P = lambda v: L_1 + v * (L_2 - L_1)
    x, y = zip(P(-2), P(2))
    with fig.batch_update(): 
        fig.data[0].update({"x": x, "y": y}) 
        fig.data[1].update({"x": [L_1[0], L_2[0]], "y": [L_1[1], L_2[1]]}) 
        fig.data[2].update({"x": [P(v)[0]], "y": [P(v)[1]]})
```
è”ç«‹è§£å‡ºä¸Šé¢çš„å°„çº¿å’Œçº¿æ®µè¡¨è¾¾å¼:
$$
O+uD=L_1+v(L_2-L_1)\\
uD-v(L_2-L_1)=L_1-O\\
\begin{pmatrix}D_x & (L_1-L_2)_x \\ D_y & (L_1-L_2)_y\end{pmatrix}\begin{pmatrix}u\\v\end{pmatrix}=\begin{pmatrix}(L_1-O)_x\\(L_1-O)_y\end{pmatrix}
$$
ä¸€æ—¦æ‰¾åˆ°äº†$u$å’Œ$v$çš„å€¼æ»¡è¶³æ–¹ç¨‹(å¦‚æœå¹³è¡Œå°±æ— è§£),æˆ‘ä»¬åªéœ€è¦æ£€æŸ¥$u\ge0$å’Œ$v\in[0,1]$æ˜¯å¦åŒæ—¶æ»¡è¶³å³å¯.

### Exercise - å“ªäº›çº¿æ®µå’Œå°„çº¿ç›¸äº¤?
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´ğŸ”´âšªâšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µâšªâšªâšªâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š10-15åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
</div>

å¯¹ä»¥ä¸‹æ¯ä¸€æ¡çº¿æ®µ,ä»–ä»¬åˆ†åˆ«ä¸å…ˆå‰çš„ç›¸æœºå°„çº¿(æŒ‡ä¸Šä¸ªç»ƒä¹ ç”Ÿæˆçš„9æ¡å°„çº¿)çš„å“ªäº›ç›¸äº¤?
```python
segments = t.tensor([
    [[1.0, -12.0, 0.0], [1, -6.0, 0.0]], 
    [[0.5, 0.1, 0.0], [0.5, 1.15, 0.0]], 
    [[2, 12.0, 0.0], [2, 21.0, 0.0]]
])
```
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution - ç›¸äº¤çš„å°„çº¿</summary>
    è¿è¡Œä»¥ä¸‹ä»£ç æ¥å¯è§†åŒ–å°„çº¿å’Œçº¿æ®µ:
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    render_lines_with_plotly(rays1d, segments)

</div>
    <li>çº¿æ®µ0å’Œå‰ä¸¤æ¡å°„çº¿ç›¸äº¤.</li>
    <li>çº¿æ®µ1ä¸ä¸ä»»ä½•å°„çº¿ç›¸äº¤.</li>
    <li>çº¿æ®µ2ä¸æœ€åä¸¤æ¡å°„çº¿ç›¸äº¤.è®¡ç®—<code>rays * 2</code>æ¥å°†å°„çº¿æŠ•å½±åˆ°<code>x=1.5</code>çš„åœ°æ–¹.è¯·è®°ä½è™½ç„¶å¯è§†åŒ–ä¸­å°†å°„çº¿æ˜¾ç¤ºä¸ºçº¿æ®µ,ä½†å°„çº¿åœ¨æ¦‚å¿µä¸Šæ˜¯æ— é™å»¶ä¼¸çš„.</li>
</details>
</div>

### Exercise - å®Œæˆ`intersect_ray_1d`
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´ğŸ”´âšªâšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µğŸ”µğŸ”µğŸ”µâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š20-25åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
<span class="token token key atrule">è¿™é‡ŒåŒ…æ‹¬äº†ä»Šå¤©çš„æ ¸å¿ƒæ¦‚å¿µ:</span>å¼ é‡æ“ä½œ,çº¿æ€§è¿ç®—ç­‰
</div>

ä½¿ç”¨[`torch.lingalg.solve`](https://pytorch.org/docs/stable/generated/torch.linalg.solve.html)å’Œ[`torch.stack`](https://pytorch.org/docs/stable/generated/torch.stack.html)å®Œæˆ`intersect_ray_1d`å‡½æ•°æ¥è§£å‡ºä¸Šé¢çš„çŸ©é˜µæ–¹ç¨‹.
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Aside - stackå’Œconcatenateçš„åŒºåˆ«</summary>
    torch.stackå°†æ²¿ç€ä¸€ä¸ªæ–°ç»´åº¦ç»„åˆä¸¤ä¸ªå¼ é‡.
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    >>> t.stack([t.ones(2, 2), t.zeros(2, 2)], dim=0)
    tensor([[[1., 1.],
            [1., 1.]],

            [[0., 0.],
            [0., 0.]]])

</div>
    <code>torch.concat</code>(åˆ«å<code>torch.cat</code>)å°†æ²¿ç€ä¸€ä¸ªå·²å­˜åœ¨çš„ç»´åº¦ç»„åˆä¸¤ä¸ªå¼ é‡.
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    >>> t.cat([t.ones(2, 2), t.zeros(2, 2)], dim=0)
    tensor([[1., 1.], 
            [1., 1.],
            [0., 0.],
            [0., 0.]])

</div>
åœ¨è¿™ä¸ªç»ƒä¹ ä¸­,ä½ åº”å½“ä½¿ç”¨<code>torch.stack</code>æ¥æ„å»ºä¾‹å¦‚ä¸Šé¢æ–¹ç¨‹å·¦ä¾§çš„çŸ©é˜µ,å› ä¸ºä½ æƒ³è¦ç»„åˆå‘é‡Då’ŒL1-L2åˆ¶ä½œä¸€ä¸ªçŸ©é˜µ.
</details>
</div>

ä¸Šé¢çš„solveæ–¹æ³•æœ‰å¤±è´¥çš„å¯èƒ½å—?ç»™å‡ºå¯èƒ½ä¼šè®©ä¸Šé¢è¿™ç§æ–¹æ³•å¤±è´¥çš„æƒ…å†µçš„ç¤ºä¾‹è¾“å…¥.
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Answer - å¤±è´¥çš„solve</summary>
    å¦‚æœå°„çº¿å’Œçº¿æ®µå®Œå…¨å¹³è¡Œ,åˆ™solveå°†å¤±è´¥,å› ä¸ºæ–¹ç¨‹ç»„æ— è§£.å¯¹äºè¿™ä¸ªå‡½æ•°,ä½ åº”è¯¥é€šè¿‡æ•è·å¼‚å¸¸å¹¶è¿”å›Falseæ¥å¤„ç†è¿™ç§æƒ…å†µ.<br>

</details>
</div>

```python
def intersect_ray_1d(ray: t.Tensor, segment: t.Tensor) -> bool:
    '''
    ray: shape (n_points=2, n_dim=3)  # O, D points
    segment: shape (n_points=2, n_dim=3)  # L_1, L_2 points

    Return True if the ray intersects the segment.
    '''
    pass


tests.test_intersect_ray_1d(intersect_ray_1d)
tests.test_intersect_ray_1d_special_case(intersect_ray_1d)
```
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">æ•‘ä¸€æ•‘!æˆ‘çš„ä»£ç æŠ¥äº†<code>must be batches of square matrices</code>é”™è¯¯.</summary>
    æˆ‘ä»¬çš„å…¬å¼ç°åœ¨åªä½¿ç”¨äº†xå’Œyåæ ‡,è¯·æš‚æ—¶ä¸è€ƒè™‘zåæ ‡.<br>
    æœ€å¥½çš„åšæ³•æ˜¯æ ¹æ®é¢„æƒ³è¾“å…¥å¼ é‡çš„å½¢çŠ¶å†™assert,è¿™æ ·ä½ çš„assertå°±ä¼šæŠ¥é”™å¹¶è¿”å›æœ‰ç”¨çš„æŠ¥é”™ä¿¡æ¯.åœ¨è¿™ä¸ªç»ƒä¹ ä¸­,ä½ å¯ä»¥assert<code>mat</code>å‚æ•°çš„å½¢çŠ¶ä¸º(2, 2),è€Œ<code>vec</code>å‚æ•°çš„å½¢çŠ¶ä¸º(2,).å¦å¤–,è¯·çœ‹çœ‹æœ‰å…³ç±»å‹æ£€æŸ¥çš„Aside.

</details>
</div>

<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    æ³¨æ„æˆ‘ä»¬åœ¨ä»£ç æœ€åä½¿ç”¨äº†<code>.item()</code>.è¿™ä¸ªæ–¹æ³•å°†ä¸€ä¸ªå®é™…ä¸Šçš„æ ‡é‡å€¼çš„æ•°æ®ç±»å‹ä»PyTorchå¼ é‡è½¬ä¸ºäº†Pythonæ ‡é‡.<br>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    def intersect_ray_1d(ray: t.Tensor, segment: t.Tensor) -> bool:
        '''
        ray: shape (n_points=2, n_dim=3)  # O, D points
        segment: shape (n_points=2, n_dim=3)  # L_1, L_2 points

        Return True if the ray intersects the segment.
        '''
        # SOLUTION
        # Get the x and y coordinates (ignore z)
        ray = ray[..., :2]
        segment = segment[..., :2]

        # Ray is [[Ox, Oy], [Dx, Dy]]
        O, D = ray
        # Segment is [[L1x, L1y], [L2x, L2y]]
        L_1, L_2 = segment

        # Create matrix and vector, and solve equation
        mat = t.stack([D, L_1 - L_2], dim=-1)
        vec = L_1 - O

        # Solve equation (return False if no solution)
        try:
            sol = t.linalg.solve(mat, vec)
        except RuntimeError:
            return False

        # If there is a solution, check the soln is in the correct range for there to be an intersection
        u = sol[0].item()
        v = sol[1].item()
        return (u >= 0.0) and (v >= 0.0) and (v <= 1.0)

</div>
</details>
</div>

### Aside - ç±»å‹æ£€æŸ¥
ç±»å‹æ£€æŸ¥æ˜¯ä¸€ä¸ªå€¼å¾—åŸ¹å…»çš„å¥½ä¹ æƒ¯.ä»–ä¸æ˜¯ä¸¥æ ¼å¿…é¡»çš„,ä½†å¯ä»¥åœ¨ä½ debugçš„æ—¶å€™æä¾›å¾ˆå¤§çš„å¸®åŠ©.

ä¸€ä¸ªåœ¨PyTorchä¸­è¿›è¡Œç±»å‹æ£€æŸ¥çš„å¥½æ–¹æ³•æ˜¯ä½¿ç”¨`jaxtyping`åº“.åœ¨è¿™ä¸ªåº“ä¸­,æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼`Float`,`Int`,`Bool`çš„ä¸œè¥¿æ¥æŒ‡å®šä¸€ä¸ªå¼ é‡çš„å½¢çŠ¶å’Œæ•°æ®ç±»å‹(æˆ–è€…ä»…ä»…`Shaped`å¦‚æœæˆ‘ä»¬ä¸å…³å¿ƒå…·ä½“çš„æ•°æ®ç±»å‹).

åœ¨æœ€ç®€å•çš„ä½¿ç”¨å½¢å¼ä¸­,è¿™å°±åƒæ–‡æ¡£å­—ç¬¦ä¸²æˆ–è€…æ³¨é‡Šçš„é«˜çº§ç‰ˆæœ¬(ç»™ä½ å’Œä½ ä»£ç çš„è¯»è€…ä¸€ä¸ªæé†’,è¿™ä¸ªå¯¹è±¡çš„å¤§å°åº”è¯¥æ˜¯å¤šå°‘).å½“ç„¶ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨`typeguard`åº“æ¥ä¸¥æ ¼æ‰§è¡Œè¾“å…¥è¾“å‡ºçš„ç±»å‹ç­¾å.ä¾‹å¦‚,è€ƒè™‘ä¸‹é¢çš„ç±»å‹æ£€æŸ¥å‡½æ•°:
```python
from jaxtyping import Float, Int, Bool, Shaped, jaxtyped
import typeguard
from torch import Tensor

@jaxtyped
@typeguard.typechecked
def my_concat(x: Float[Tensor, "a1 b"], y: Float[Tensor, "a2 b"]) -> Float[Tensor, "a1+a2 b"]:
    return t.concat([x, y], dim=0)

x = t.ones(3, 2)
y = t.randn(4, 2)
z = my_concat(x, y)
```

è¿™æ®µä»£ç è¿è¡Œä¸ä¼šæŠ¥é”™,å› ä¸ºå¼ é‡`t.concat([x, y], dim=0)`å½¢çŠ¶ä¸º`(3+4, 2) = (7, 2)`,å’Œç±»å‹ç­¾å`(a1 b), (a2 b) -> (a1+a2 b)`è¡¨ç¤ºä¸€è‡´.ä½†æ˜¯,å¦‚æœç”¨ä»»ä½•æ–¹å¼è¿åç±»å‹ç­¾å,æ­¤ä»£ç å°†æŠ¥é”™,ä¾‹å¦‚:
- `x`æˆ–`y`ä¸æ˜¯2Då¼ é‡.
- `x`å’Œ`y`çš„æœ€åä¸€ä¸ªç»´åº¦ä¸åŒ¹é….
- è¾“å‡ºå¼ é‡çš„å½¢çŠ¶ä¸æ»¡è¶³`(x.shape[0]+y.shape[0], x.shape[1])`.
- `x`æˆ–`y`æˆ–è¾“å‡ºå¼ é‡çš„æ•°æ®æ˜¯æ•´å‹è€Œä¸æ˜¯æµ®ç‚¹å‹.

ä½ å¯ä»¥é€šè¿‡æ›´æ”¹ä¸Šé¢ä»£ç å—ä¸­çš„å…·ä½“ä»£ç å¹¶é‡æ–°è¿è¡Œæ¥äº²è‡ªæµ‹è¯•è¿™äº›.

Jaxtypingè¿˜æœ‰è®¸å¤šå…¶ä»–æœ‰ç”¨çš„ç‰¹æ€§,æ¯”å¦‚:
- é€šç”¨å¼ é‡å¯ä»¥ç”¨`Float[Tensor, "..."]`æ–¹å¼æ¥è¡¨ç¤º.
- ä»…æœ‰å•ä¸ªæ ‡é‡å€¼çš„å¼ é‡å¯ä»¥ç”¨`Float[Tensor, ""]`æ–¹å¼æ¥è¡¨ç¤º.
- å›ºå®šå¤§å°çš„ç»´åº¦å¯ä»¥ç›´æ¥ç”¨æ•°å­—è¡¨ç¤º,ä¾‹å¦‚`Float[Tensor, "a b 4"]`.
- ç»´åº¦å¯ä»¥è¢«å‘½åå’Œèµ‹å€¼å›ºå®š,ä¾‹å¦‚å¦‚æœ`x`å’Œ`y`çš„å½¢çŠ¶ä¸åŒæ—¶ä¸º`(3,)`,åˆ™`x: Float[Tensor, "b=3"], y: Float[Tensor, "b"]`ä¼šæŠ¥é”™.
- ä½ ç”šè‡³å¯ä»¥åœ¨è¡Œå†…asserté‡Œé¢ä½¿ç”¨è¿™äº›ç±»å‹åˆ¤æ–­,ä¾‹å¦‚`assert isinstance(x, Float[Tensor, "b"])`ä¼šåˆ¤æ–­`x`æ˜¯ä¸æ˜¯ä¸€ä¸ªæ•°æ®ç±»å‹ä¸ºæµ®ç‚¹å‹,ç¬¬ä¸€ä¸ªç»´åº¦æ˜¯3çš„2Då¼ é‡.

ä½ å¯ä»¥åœ¨[è¿™é‡Œ](https://docs.kidger.site/jaxtyping/)æ‰¾åˆ°æ›´å¤š`jaxtyping`çš„ç‰¹æ€§.

æ€»è€Œè¨€ä¹‹,ç±»å‹æ£€æŸ¥æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å·¥å…·,å› ä¸ºä»–å¯ä»¥å¸®åŠ©ä½ å¿«é€Ÿæ•è·ä»£ç ä¸­çš„é”™è¯¯,å¹¶è®©ä½ çš„ä»£ç æ›´æ¸…æ™°æ˜“è¯»,å¯¹äºä½ å¯èƒ½çš„åä½œè€…,ç»“å¯¹ç¼–ç¨‹é˜Ÿå‹ç”šè‡³æ˜¯æœªæ¥çš„è‡ªå·±éƒ½æ˜¯å¾ˆæœ‰ç”¨çš„!

ä¸€èˆ¬æ¥è¯´,æˆ‘ä»¬ä¸ä¼šå¼ºåˆ¶æ‰§è¡Œä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥,ä½†æ˜¯ä½ åœ¨ç¼–å†™æˆ–ä½¿ç”¨å‡½æ•°æ—¶åº”è¯¥éšæ„ä½¿ç”¨ä»–(ä»–åœ¨ä½ çš„å¼€å‘è¿‡ç¨‹æ˜¯æœ€æœ‰ç”¨çš„,è€Œä¸æ˜¯ä½ å·²ç»å®Œå…¨ç¡®å®šå‡½æ•°å¯ä»¥æ­£å¸¸å·¥ä½œå¹¶å§‹ç»ˆä¼šå¾—åˆ°æ­£å¸¸çš„è¾“å…¥æ—¶).

Exercise - ä½ èƒ½ç”¨ç±»å‹æ£€æŸ¥æŠŠå‡½æ•°`intersect_ray_1d`é‡æ–°å†™ä¸€éå—?
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    ä½ çš„ç±»å‹æ£€æŸ¥ç‰ˆæœ¬çš„å‡½æ•°åº”è¯¥é•¿è¿™æ ·:<br>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    @jaxtyped
    @typeguard.typechecked
    def intersect_ray_1d(ray: Float[Tensor, "points=2 dim=3"], segment: Float[Tensor, "points=2 dim=3"]) -> bool:
        '''
        ray: O, D points
        segment: L_1, L_2 points

        Return True if the ray intersects the segment.
        '''

</div>
    è¿™é‡Œå‡å®šä½ çš„è§£ç­”ä¸­å‡½æ•°åªä¼šè¿”å›boolå€¼.å¦‚æœä½ å°†boolå€¼ä¿ç•™ä¸ºå•å…ƒç´ PyTorchå¼ é‡,è¿”å›ç±»å‹åº”è¯¥æ”¹æˆ<code>Bool[Tensor, ""]</code><br>
</details>
</div>
