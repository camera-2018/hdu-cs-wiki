# ä¸‰è§’å½¢(Triangles)
## ä¸‰è§’å½¢åæ ‡(Triangle Coordinates)
ä¸‰è§’å½¢å†…çš„åŒºåŸŸå¯ä»¥ç”¨ä¸‰ä¸ªéå…±çº¿çš„ç‚¹$A$,$B$,$C$å®šä¹‰,å¹¶å¯ä»¥ç”¨ä»£æ•°å½¢å¼å†™ä¸ºä¸‰ä¸ªç‚¹çš„**å‡¸ç»„åˆ**:
$$
P(w,u,v)=wA+uB+vC\\s.t.\quad0\le w,u,v\\1=w+u+v
$$
æˆ–è€…ç­‰ä»·äº

<div style="overflow:auto">


$$
P(u,v)=(1-u-v)A+uB+vC\\\ =A+u(B-A)+v(C-A)\\s.t.\quad0\le u,v\\u+v\le 1
$$

</div>

è¿™é‡Œ$u$,$v$è¢«ç§°ä¸º"é‡å¿ƒåæ ‡".
å¦‚æœæˆ‘ä»¬åˆ é™¤$u$å’Œ$v$çš„èŒƒå›´,æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸‰è§’å½¢æ‰€åœ¨å¹³é¢çš„è¡¨è¾¾å¼.ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶æ¥äº†è§£$u$å’Œ$v$çš„è¡Œä¸º.
```python
one_triangle = t.tensor([[0, 0, 0], [3, 0.5, 0], [2, 3, 0]])
A, B, C = one_triangle
x, y, z = one_triangle.T

fig = setup_widget_fig_triangle(x, y, z)

@interact(u=(-0.5, 1.5, 0.01), v=(-0.5, 1.5, 0.01))
def response(u=0.0, v=0.0):
    P = A + u * (B - A) + v * (C - A)
    fig.data[2].update({"x": [P[0]], "y": [P[1]]})

display(fig)
```

### ä¸‰è§’-å°„çº¿ç›¸äº¤
ç»™å®šä¸€æ¡å°„çº¿çš„åŸç‚¹$O$å’Œæ–¹å‘$D$,æˆ‘ä»¬çš„ç›¸äº¤ç®—æ³•å°†åŒ…å«ä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤:
- é€šè¿‡è”ç«‹æ–¹ç¨‹$P(u,v)=P(s)$æ¥è®¡ç®—äº¤ç‚¹åæ ‡.
- æ£€æŸ¥$u$å’Œ$v$æ˜¯å¦æ»¡è¶³èŒƒå›´.

å±•å¼€ç­‰å¼$P(u,v)=P(s)$,æˆ‘ä»¬æœ‰:
<div style="overflow:auto">

$$
A+u(B-A)+v(C-A)=O+sD\\
\Rightarrow\begin{pmatrix}-D&(B-A)&(C-A)\end{pmatrix}\begin{pmatrix}s\\u\\v\end{pmatrix}=(O-A)\\
\Rightarrow\begin{pmatrix}-D_x&(B-A)_x&(C-A)_x\\-D_y&(B-A)_y&(C-A)_z\\-D_z&(B-A)_z&(C-A)_z\end{pmatrix}\begin{pmatrix}s\\u\\v\end{pmatrix}=\begin{pmatrix}(O-A)_x\\(O-A)_y\\(O-A)_z\end{pmatrix}
$$

</div>
å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡æ±‚è§£è¿™ä¸ªçº¿æ€§æ–¹ç¨‹è§£å‡ºäº¤ç‚¹çš„åæ ‡`s`,`u`å’Œ`v`.

### Exercise-å®Œæˆ`triangle_ray_intersects`
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´ğŸ”´âšªâšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µğŸ”µğŸ”µâšªâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š15-20åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
</div>

ä½¿ç”¨`torch.linalg.solve`å’Œ`torch.stack`,å®Œæˆ`triangle_ray_intersects(A, B, C, O, D)`

ä¸€äº›æç¤º:
- å¦‚æœä½ æœ‰ä¸€ä¸ªé›¶ç»´çš„å¼ é‡,å½¢çŠ¶ä¸º`()`,åªå‚¨å­˜äº†å•ä¸ªå€¼,è¯·ä½¿ç”¨`.item()`æ–¹æ³•æŠŠä»–è½¬æ¢ä¸ºæ™®é€šçš„Pythonå€¼.
- å¦‚æœä½ æœ‰ä¸€ä¸ªå½¢çŠ¶ä¸º`tensor.shape = (3, ...)`çš„å¼ é‡,é‚£ä¹ˆä½ å¯ä»¥ç”¨ç±»ä¼¼`s, u, v = tensor`çš„æ–¹æ³•æ²¿ç€ç¬¬ä¸€ä¸ªç»´åº¦æŠŠè¿™ä¸ªå¼ é‡åˆ†è§£æˆä¸‰ä¸ªç‹¬ç«‹çš„å¼ é‡,å°±å’Œä½ åˆ†è§£pythonä¸­çš„åˆ—è¡¨ä¸€æ ·.
    - æ³¨æ„,å¦‚æœä½ æƒ³è¦åˆ†è§£çš„ç»´åº¦ä¸åœ¨ç¬¬ä¸€ä¸ªç»´åº¦,æœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ›¿æ¢æ–¹æ³•æ˜¯`s, u, v = tensor.unbind(dim)`,å…¶ä¸­`dim`æŒ‡å®šäº†ä½ æƒ³è¦æ‹†åˆ†çš„ç»´åº¦.
- å¦‚æœä½ å‡½æ•°æ²¡æ­£å¸¸å·¥ä½œ,å°è¯•ç”¨æ¼‚äº®çš„æ•´æ•°åˆ¶ä½œä¸€ä¸ªç®€å•çš„å°„çº¿å’Œä¸‰è§’å½¢,æ‰‹åŠ¨è®¡ç®—æ˜¯å¦ç›¸äº¤,ç„¶åä»è¿™å¼€å§‹æ…¢æ…¢è°ƒè¯•.

```python
Point = Float[Tensor, "points=3"]

@jaxtyped
@typeguard.typechecked
def triangle_ray_intersects(A: Point, B: Point, C: Point, O: Point, D: Point) -> bool:
    '''
    A: shape (3,), one vertex of the triangle
    B: shape (3,), second vertex of the triangle
    C: shape (3,), third vertex of the triangle
    O: shape (3,), origin point
    D: shape (3,), direction point

    Return True if the ray and the triangle intersect.
    '''
    pass


tests.test_triangle_ray_intersects(triangle_ray_intersects)
```

<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    def triangle_ray_intersects(A: Point, B: Point, C: Point, O: Point, D: Point) -> bool:
        '''
        A: shape (3,), one vertex of the triangle
        B: shape (3,), second vertex of the triangle
        C: shape (3,), third vertex of the triangle
        O: shape (3,), origin point
        D: shape (3,), direction point

        Return True if the ray and the triangle intersect.
        '''
        # SOLUTION
        s, u, v = t.linalg.solve(
            t.stack([-D, B - A, C - A], dim=1), 
            O - A
        )
        return ((u >= 0) & (v >= 0) & (u + v <= 1)).item()

</div>
</details>
</div>

## æ¸²æŸ“å•ä¸ªä¸‰è§’å½¢(Single-Triangle Rendering)
åœ¨ä»…è°ƒç”¨`torch.linagl.solve`çš„å‰æä¸‹å®Œæˆ`raytrace_triangle`.

é‡å¡‘è¾“å‡ºå¼ é‡å¹¶ä½¿ç”¨`plt.imshow`è¿›è¡Œå¯è§†åŒ–.è¾¹ç¼˜åƒç´ åŒ–å’Œé”¯é½¿çŠ¶æ˜¯æ­£å¸¸çš„ - ä½¿ç”¨å°‘é‡åƒç´ æ˜¯å¿«é€Ÿè°ƒè¯•çš„å¥½æ–¹æ³•.

å¦‚æœä½ è§‰å¾—ä½ çš„ä»£ç å·²ç»èƒ½æ­£å¸¸è·‘äº†,è¯·å¢åŠ åƒç´ çš„æ•°é‡éªŒè¯æ›´é«˜åˆ†è¾¨ç‡ä¸‹è¾¹ç¼˜åƒç´ åŒ–ç¨‹åº¦æ˜¯å¦é™ä½.

### è§†å›¾å’Œå‰¯æœ¬(Views and Copies)
çŸ¥é“ä½ ä»€ä¹ˆæ—¶å€™åˆ›å»ºäº†`Tensor`çš„å‰¯æœ¬è€Œä¸æ˜¯åˆ›å»ºäº†ä¸åŸå§‹å¼ é‡å…±äº«æ•°æ®çš„è§†å›¾æ˜¯å¾ˆé‡è¦çš„.å°½å¯èƒ½ä½¿ç”¨è§†å›¾æ˜¯æœ€å¥½çš„,å¯ä»¥é¿å…ä¸å¿…è¦çš„å†…å­˜ç©ºé—´å ç”¨.ä½†æ˜¯å¦ä¸€æ–¹é¢,ä¿®æ”¹è§†å›¾ä¼šä¿®æ”¹åŸå§‹å¼ é‡,æœ‰æ—¶å€™å¯èƒ½ä¼šé€ æˆä¸€äº›å¥‡æ€ªçš„ç»“æœ.å¦‚æœä½ ä¸ç¡®å®šå‡½æ•°æ˜¯å¦è¿”å›è§†å›¾,è¯·å‚é˜…[æ–‡æ¡£](https://pytorch.org/docs/stable/tensor_view.html).å¸¸ç”¨å‡½æ•°è¿”å›æƒ…å†µé€ŸæŸ¥:
- `torch.expand`: æ€»æ˜¯è¿”å›è§†å›¾
- `torch.view`: æ€»æ˜¯è¿”å›è§†å›¾
- `torch.detach`: æ€»æ˜¯è¿”å›è§†å›¾
- `torch.repeat`: æ€»æ˜¯å¤åˆ¶
- `torch.clone`: æ€»æ˜¯å¤åˆ¶
- `torch.flip`: æ€»æ˜¯å¤åˆ¶(å’Œ`numpy.flip`ä¸åŒ,åè€…æ€»æ˜¯è¿”å›è§†å›¾)
- `torch.tensor`: æ€»æ˜¯å¤åˆ¶,ä½†æ˜¯PyTorchæ¨èä½¿ç”¨`.clone().detach()`æ›¿æ¢è¯¥å‡½æ•°
- `torch.Tensor.contiguous`: å¦‚æœå¯ä»¥å°±è¿”å›è‡ªèº«,å¦åˆ™å°±è¿”å›å‰¯æœ¬
- `torch.transpose`: å¦‚æœå¯ä»¥å°±è¿”å›è§†å›¾,å¦åˆ™å°±è¿”å›å‰¯æœ¬
- `torch.reshape`: å¦‚æœå¯ä»¥å°±è¿”å›è§†å›¾,å¦åˆ™å°±è¿”å›å‰¯æœ¬
- `torch.flatten`: å¦‚æœå¯ä»¥å°±è¿”å›è§†å›¾,å¦åˆ™å°±è¿”å›å‰¯æœ¬(å’Œ`numpy.flatten`ä¸åŒ,åè€…æ€»æ˜¯è¿”å›å‰¯æœ¬)
- `einops.repeat`: å¦‚æœå¯ä»¥å°±è¿”å›è§†å›¾,å¦åˆ™å°±è¿”å›å‰¯æœ¬
- `einops.rearrange`: å¦‚æœå¯ä»¥å°±è¿”å›è§†å›¾,å¦åˆ™å°±è¿”å›å‰¯æœ¬
- åŸºç¡€ç´¢å¼•ä¼šè¿”å›è§†å›¾,é«˜çº§ç´¢å¼•ä¼šè¿”å›å‰¯æœ¬.

### å­˜å‚¨å¯¹è±¡
åœ¨ä¸€ä¸ª`Tensor`ä¸Šè°ƒç”¨`storage()`ä¼šè¿”å›ä¸€ä¸ªåŒ…è£…äº†åº•å±‚C++æ•°ç»„çš„Pythonå¯¹è±¡.æ— è®º`Tensor`çš„ç»´æ•°æ˜¯å¤šå°‘,è¿™éƒ½æ˜¯ä¸ªä¸€ç»´æ•°ç»„.è¿™èƒ½è®©ä½ çœ‹åˆ°`Tensor`æŠ½è±¡å‰çš„å†…å®¹å¹¶äº†è§£åˆ°å®é™…æ•°æ®åœ¨å†…å­˜ä¸­çš„æ’å¸ƒæ–¹å¼.

è¯·æ³¨æ„æ¯æ¬¡è°ƒç”¨`storage()`éƒ½ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„pythonåŒ…è£…å¯¹è±¡,å¹¶ä¸”`x.storage() == x.storage()`å’Œ`x.storage() is x.storage()`ç»“æœå‡ä¸ºFalse.

å¦‚æœéœ€è¦æ£€æŸ¥ä¸¤ä¸ª`Tensor`æ˜¯å¦å…±äº«åº•å±‚çš„C++æ•°ç»„,å¯ä»¥æ¯”è¾ƒä»–ä»¬çš„`storage().data_ptr()`å­—æ®µ,è¿™æ˜¯ä»–ä»¬åº•å±‚C++æ•°ç»„åœ¨å†…å­˜ä¸­çš„æŒ‡é’ˆ.è¿™å¯¹äºè°ƒè¯•å¾ˆæœ‰ç”¨.

### `Tensor._base`
å¦‚æœ`x`æ˜¯ä¸€ä¸ªè§†å›¾,ä½ å¯ä»¥ç”¨`x._base`è®¿é—®ä»–çš„åŸå§‹`Tensor`.è¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰å†™åœ¨æ–‡æ¡£é‡Œçš„å†…éƒ¨åŠŸèƒ½,äº†è§£ä¸€ä¸‹å¾ˆæœ‰ç”¨.è€ƒè™‘ä¸‹é¢è¿™æ®µä»£ç :
```python
x = t.zeros(1024*1024*1024)
y = x[0]
del x
```

è¿™é‡Œ,`y`æ˜¯é€šè¿‡åŸºç¡€ç´¢å¼•åˆ›å»ºçš„,æ‰€ä»¥`y`æ˜¯ä¸€ä¸ªè§†å›¾ä¸”`y._base`æŒ‡å‘`x`.è¿™æ„å‘³ç€æ‰§è¡Œ`del x`åç³»ç»Ÿä¸ä¼šé‡Šæ”¾4GBå†…å­˜,è¯¥ç©ºé—´ä»ç„¶ä¼šè¢«ç»§ç»­ä½¿ç”¨,è¿™ä¸ªç»“æœå¯èƒ½ä¼šéå¸¸åç›´è§‰.ä½ å¯ä»¥ç”¨`y = x[0].clone()`è¿›è¡Œæ›¿æ¢,ä½¿ç”¨è¿™ä¸ªæ–¹æ³•åå…è®¸ä½ å›æ”¶`x`çš„å†…å­˜.

### Exercise-å®Œæˆ`raytrace_triangle`
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´ğŸ”´ğŸ”´âšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µğŸ”µğŸ”µğŸ”µâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š15-20åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
è¿™ä¸ªç»ƒä¹ å’Œ<code>intersect_rays_1d</code>éš¾åº¦å·®ä¸å¤š,ä½†æˆ‘è¿˜æ˜¯å¸Œæœ›ä½ èƒ½å®Œæˆçš„æ›´ç†Ÿç»ƒ.<br>
</div>

ä½ éœ€è¦å®Œæˆå‡½æ•°`raytrace_triangle`,åŠŸèƒ½æ˜¯èƒ½æ£€æµ‹`ray`ä¸­çš„æ¯æ¡å°„çº¿æ˜¯å¦å’Œä¸€ä¸ªç»™å®šçš„ä¸‰è§’å½¢ç›¸äº¤.
```python
def raytrace_triangle(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangle: Float[Tensor, "trianglePoints=3 dims=3"]
) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if the triangle intersects that ray.
    '''
    pass


A = t.tensor([1, 0.0, -0.5])
B = t.tensor([1, -0.5, 0.0])
C = t.tensor([1, 0.5, 0.5])
num_pixels_y = num_pixels_z = 15
y_limit = z_limit = 0.5

# Plot triangle & rays
test_triangle = t.stack([A, B, C], dim=0)
rays2d = make_rays_2d(num_pixels_y, num_pixels_z, y_limit, z_limit)
triangle_lines = t.stack([A, B, C, A, B, C], dim=0).reshape(-1, 2, 3)
render_lines_with_plotly(rays2d, triangle_lines)

# Calculate and display intersections
intersects = raytrace_triangle(rays2d, test_triangle)
img = intersects.reshape(num_pixels_y, num_pixels_z).int()
imshow(img, origin="lower", width=600, title="Triangle (as intersected by rays)")
```

<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">
    
    def raytrace_triangle(
        rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
        triangle: Float[Tensor, "trianglePoints=3 dims=3"]
    ) -> Bool[Tensor, "nrays"]:
        '''
        For each ray, return True if the triangle intersects that ray.
        '''
        # SOLUTION
        NR = rays.size(0)

        # Triangle is [[Ax, Ay, Az], [Bx, By, Bz], [Cx, Cy, Cz]]
        A, B, C = einops.repeat(triangle, "pts dims -> pts NR dims", NR=NR)
        assert A.shape == (NR, 3)

        # Each element of `rays` is [[Ox, Oy, Oz], [Dx, Dy, Dz]]
        O, D = rays.unbind(dim=1)
        assert O.shape == (NR, 3)

        # Define matrix on left hand side of equation
        mat: Float[Tensor, "NR 3 3"] = t.stack([- D, B - A, C - A], dim=-1)

        # Get boolean of where matrix is singular, and replace it with the identity in these positions
        # Note - this works because mat[is_singular] has shape (NR_where_singular, 3, 3), so we
        # can broadcast the identity matrix to that shape.
        dets: Float[Tensor, "NR"] = t.linalg.det(mat)
        is_singular = dets.abs() < 1e-8
        mat[is_singular] = t.eye(3)

        # Define vector on the right hand side of equation
        vec = O - A

        # Solve eqns
        sol: Float[Tensor, "NR 3"] = t.linalg.solve(mat, vec)
        s, u, v = sol.unbind(dim=-1)

        # Return boolean of (matrix is nonsingular, and solution is in correct range implying intersection)
        return ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)

</div>
</details>
</div>

## è°ƒè¯•(Debugging)
è°ƒè¯•ä»£ç æ˜¯ä¸€ä»¶éå¸¸é‡è¦çš„äº‹.å°±åƒç”¨GPTè¾…åŠ©ä»£ç ä¸€æ ·,ä»–å¯ä»¥æ˜¾è‘—åŠ å¿«ä½ çš„å¼€å‘é€Ÿåº¦,è®©ä½ ä¸å†bugä¸Šæµªè´¹è¿‡å¤šçš„æ—¶é—´.

ä¸ºäº†è®©ä½ ç»ƒä¹ ä½¿ç”¨VSCodeçš„å†…ç½®è°ƒè¯•å™¨è¿›è¡Œè°ƒè¯•,ä¸‹é¢æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç¤ºä¾‹å‡½æ•°.è¿™æ˜¯`raytrace_triangle`çš„ä¸€ä¸ªå®ç°,å…¶ä¸­æœ‰ä¸€äº›é”™è¯¯.ä½ çš„ä»»åŠ¡æ˜¯ä½¿ç”¨è°ƒè¯•å™¨æ‰¾åˆ°é”™è¯¯å¹¶ä¿®å¤å®ƒ(å½“ç„¶æˆ‘çŸ¥é“æˆ‘ä»¬ä¸Šé¢å·²ç»æä¾›äº†solutionä½ åº”è¯¥ä¹Ÿå·²ç»çœ‹è¿‡äº†,ä½†æ˜¯è¿™ä¸ªéƒ¨åˆ†æ˜¯ä¸ºäº†è®­ç»ƒä½ ä½¿ç”¨VSCodeå†…ç½®è°ƒåˆ¶å™¨çš„èƒ½åŠ›,æ‰€ä»¥è¯·å¿˜äº†å‚è€ƒç­”æ¡ˆ!).
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">æœ‰é”™è¯¯çš„å‡½æ•°</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    def raytrace_triangle_with_bug(
        rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
        triangle: Float[Tensor, "trianglePoints=3 dims=3"]
    ) -> Bool[Tensor, "nrays"]:
        '''
        For each ray, return True if the triangle intersects that ray.
        '''
        NR = rays.size[0]

        A, B, C = einops.repeat(triangle, "pts dims -> pts NR dims", NR=NR)

        O, D = rays.unbind(-1)

        mat = t.stack([- D, B - A, C - A])

        dets = t.linalg.det(mat)
        is_singular = dets.abs() < 1e-8
        mat[is_singular] = t.eye(3)

        vec = O - A

        sol = t.linalg.solve(mat, vec)
        s, u, v = sol.unbind(dim=-1)

        return ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)


    intersects = raytrace_triangle_with_bug(rays2d, test_triangle)
    img = intersects.reshape(num_pixels_y, num_pixels_z).int()
    imshow(img, origin="lower", width=600, title="Triangle (as intersected by rays)")    

</div>
</details>
</div>

ä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å•å…ƒæ ¼åº•éƒ¨çš„**Debug cell(è°ƒè¯•å•å…ƒæ ¼)**æ¥è°ƒè¯•.ä½ çš„å•å…ƒæ ¼åº”è¯¥åŒ…å«å®é™…è¿è¡Œæ—¶å¯¼è‡´é”™è¯¯çš„ä»£ç (è€ŒéåŒ…å«é”™è¯¯æ¥æºçš„å‡½æ•°).åœ¨è¿è¡Œè°ƒè¯•å™¨ä¹‹å‰,ä½ å¯ä»¥é€šè¿‡å•å‡»è¡Œå·å·¦ä¾§(å•æœºåå°†å‡ºç°ä¸€ä¸ªçº¢ç‚¹)æ¥è®¾ç½®æ–­ç‚¹.ç„¶å,ä½ å¯ä»¥ä½¿ç”¨è°ƒè¯•å™¨è¿è¡Œæ—¶å‡ºç°çš„æŒ‰é’®å·¥å…·æ å•æ­¥è°ƒè¯•ä»£ç (å‚é˜…[è¿™é‡Œ](https://pawelgrzybek.com/continue-step-over-step-into-and-step-out-actions-in-visual-studio-code-debugger-explained/)ä»¥äº†è§£æ¯ä¸ªæŒ‰é’®çš„åŠŸèƒ½è¯´æ˜).å½“ç¨‹åºè¿è¡Œåˆ°æ–­ç‚¹æ—¶,ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·:
- åœ¨å·¦ä¾§è¾¹æ **VARIABLES(å˜é‡)** çª—å£ä¸­æ£€æŸ¥å±€éƒ¨å’Œå…¨å±€å˜é‡.
- åœ¨å·¦ä¾§è¾¹æ **WATCH(è§‚å¯Ÿ)** çª—å£ä¸­æ·»åŠ è¦è§‚å¯Ÿçš„å˜é‡è¡¨è¾¾å¼.
    - ä½ å¯ä»¥åœ¨è¿™é‡Œè¾“å…¥ä»»ä½•è¡¨è¾¾å¼,ä¾‹å¦‚å˜é‡çš„ç±»å‹æˆ–åˆ—è¡¨çš„é•¿åº¦,è¿™å°†åœ¨ä»£ç å•æ­¥è¿è¡Œä¹‹åå®æ—¶æ›´æ–°.
- é€šè¿‡å°†è¡¨è¾¾å¼è¾“å…¥åˆ°**DEBUG CONSOLE(è°ƒè¯•æ§åˆ¶å°)** (å‡ºç°åœ¨å±å¹•åº•éƒ¨)æ¥ä¸€æ¬¡æ€§è®¡ç®—è¡¨è¾¾å¼çš„å€¼.

è¯·æ³¨æ„,ä½ çš„ä»£ç ä¼šåœ¨ä½ æ‰“æ–­ç‚¹çš„é‚£ä¸€è¡Œå¼€å§‹æ‰§è¡Œä¹‹å‰åœæ­¢æ‰§è¡Œ.å› æ­¤å¦‚æœä½ åœ¨æŸä¸€è¡Œä¸Šå‡ºç°æŠ¥é”™,ä½ éœ€è¦åšçš„å°±æ˜¯ç›´æ¥åœ¨è¿™ä¸€è¡Œæ‰“æ–­ç‚¹.

_å¦‚æœä½ åœ¨VSCodeä¸­ä½¿ç”¨jupyter notebook,é‚£ä¸Šé¢è¿™äº›å†…å®¹çš„åŸºæœ¬å·¥ä½œåŸç†éƒ½å·®ä¸å¤š,é™¤äº†ä¸€äº›å°æ›´æ”¹,ä¾‹å¦‚è°ƒè¯•æŒ‰é’®åœ¨å•å…ƒæ ¼å·¦ä¸Šè§’çš„ä¸‹æ‹‰èœå•ä¸­(å¦‚æœä½ æ‰¾ä¸åˆ°,é‚£ä¹ˆä½ éœ€è¦è¿›å…¥ç”¨æˆ·è®¾ç½®å¹¶æ·»åŠ ä¸€è¡Œ`"notebook.consolidatedRunButton": true`)._

æˆ‘ä»¬è¿˜æƒ³è®¨è®ºæœ‰å…³è°ƒè¯•çš„æ›´å¤šç»†èŠ‚,ä½†æ˜¯è¿™äº›å·²ç»è¶³å¤Ÿæ»¡è¶³å¤§å¤šæ•°éœ€æ±‚.è°ƒè¯•å™¨é€šå¸¸æ˜¯æ¯”printæˆ–è€…assertæ›´æœ‰æ•ˆçš„è°ƒè¯•æ–¹å¼(å°½ç®¡è¿™ä¸¤ä¸ªåœ¨æŸäº›æƒ…å†µä¸‹ä¹Ÿå¾ˆæœ‰å¸®åŠ©).
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Answer - è¿™äº›bugæ˜¯ä»€ä¹ˆå’Œå¦‚ä½•ä¿®å¤è¿™äº›bug.</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    NR = rays.size[0]

</div>
è¿™é‡Œåº”è¯¥æ˜¯<code>rays.size(0)</code>(æˆ–è€…ç­‰ä»·çš„<code>rays.shape[0]</code>)<code>size</code>æ˜¯ä¸€ä¸ªç±»æ–¹æ³•,éœ€è¦æ¥å—ä¸€ä¸ªæ•´æ•°ä½œä¸ºå‚æ•°å¹¶è¿”å›è¿™ä¸ªç»´åº¦çš„å½¢çŠ¶;<code>shape</code>æ˜¯ä¸€ä¸ªå®ä¾‹å±æ€§å¯ä»¥æ¥å—ç´¢å¼•.<br>
è¿™ä¸ªé—®é¢˜å°±ç®—æ²¡æœ‰è°ƒè¯•å™¨ä¹Ÿèƒ½å¾ˆå®¹æ˜“çš„è§£å†³,å› ä¸ºæŠ¥é”™ä¿¡æ¯éå¸¸è¯¦ç»†.<br>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    O, D = rays.unbind(-1)

</div>
æˆ‘ä»¬åœ¨åˆ†è§£é”™è¯¯çš„ç»´åº¦.<code>rays</code>çš„å½¢çŠ¶æ˜¯<code>(nrays, points=2, dims=3)</code>,è€Œæˆ‘ä»¬å®é™…ä¸Šæƒ³æ²¿ç€<code>points</code>ç»´åº¦åˆ†è§£.æ‰€ä»¥æˆ‘ä»¬åº”è¯¥ç”¨<code>rays.unbind(1)</code>.<br>
æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨å˜é‡çª—å£è§‚å¯Ÿ<code>rays</code>å®ä¾‹å‘ç°è¿™ä¸€ç‚¹(ä½ å¯ä»¥ç‚¹å‡»å˜é‡åçš„ä¸‹æ‹‰ç®­å¤´æ¥è§‚å¯Ÿå˜é‡çš„å±æ€§å€¼,åŒ…æ‹¬<code>shape</code>),æˆ–è€…ä½ å¯ä»¥é€šè¿‡åœ¨è°ƒè¯•æ§åˆ¶å°è¾“å…¥<code>rays.shape</code>æ¥æŸ¥çœ‹å±æ€§å€¼.è¿™ä¸ªé”™è¯¯åº”è¯¥ä¹Ÿæ˜¯æ˜¾è€Œæ˜“è§çš„(ä½¿ç”¨ç±»å‹æ£€æŸ¥çš„å¥½ä¾‹å­!).<br>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    mat = t.stack([- D, B - A, C - A])

</div>
è¿™é‡Œéœ€è¦åœ¨æœ€åå¤šä¸€ä¸ªå‚æ•°<code>dim=-1</code>,å› ä¸º<code>torch.stack</code>é»˜è®¤æ²¿ç€ç¬¬ä¸€ä¸ªç»´åº¦å †ç§¯å¼ é‡.<br>
è¿™ä¸ªé”™è¯¯å¯èƒ½æ¯”è¾ƒéš¾å‘ç°,å› ä¸ºæŠ¥é”™çš„è¡Œåœ¨å®é™…å‡ºç°é”™è¯¯çš„è¡Œå‰ä¸€è¡Œ.å½“ç„¶,æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡åœ¨å˜é‡çª—å£æ£€æŸ¥<code>mat</code>å¼ é‡çš„å½¢çŠ¶æ¥å‘ç°è¿™ä¸ªé”™è¯¯.<br>
<hr>
è¿™äº›éƒ½æ˜¯ç›¸å¯¹å®¹æ˜“å‘ç°çš„é”™è¯¯(å¹¶éæ‰€æœ‰é”™è¯¯éƒ½ä¼šåœ¨ä»£ç ä¸­æŠ¥é”™,æœ‰äº›å¯èƒ½åªæ˜¯æ„å¤–çš„ç»“æœ).ä½†å¸Œæœ›è¿™ä¸ªç»ƒä¹ èƒ½è®©ä½ äº†è§£å¦‚ä½•ä½¿ç”¨è°ƒè¯•å™¨.è¿™æ˜¯ä¸€ä¸ªéå¸¸å¼ºå¤§çš„å·¥å…·,å¯ä»¥èŠ‚çº¦ä½ å¾ˆå¤šæ—¶é—´.
</details>
</div>

## åŠ è½½Mesh
ä½¿ç”¨æä¾›çš„ä»£ç æ¥åŠ è½½ä¸‰è§’å½¢ç»„æˆçš„çš®å¡ä¸˜.æŒ‰ç…§æƒ¯ä¾‹,ä½¿ç”¨`torch.save`å†™å…¥çš„æ–‡ä»¶éƒ½ä»¥`.pt`ç»“å°¾,ä½†å®é™…ä¸Šè¿™äº›åªæ˜¯zipæ–‡ä»¶ç½¢äº†.
```python
with open(section_dir / "pikachu.pt", "rb") as f:
    triangles = t.load(f)
```

## æ¸²æŸ“Mesh
å¯¹äºæˆ‘ä»¬çš„ç›®æ ‡,meshå°±æ˜¯ä¸€ç»„ä¸‰è§’å½¢,å› æ­¤ä¸ºäº†æ¸²æŸ“å®ƒ,æˆ‘ä»¬å°†åŒæ—¶ä½¿æ‰€æœ‰å…‰çº¿å’Œæ‰€æœ‰ä¸‰è§’å½¢ç›¸äº¤.æˆ‘ä»¬ä¹‹å‰åªæ˜¯è¿”å›ä¸€ä¸ªboolå€¼åˆ¤æ–­ç»™å®šçš„å°„çº¿æ˜¯å¦ä¸ä¸‰è§’å½¢ç›¸äº¤,ä½†ç°åœ¨å¯èƒ½æœ‰å¤šä¸ªä¸‰è§’å½¢ä¸ç»™å®šçš„å°„çº¿ç›¸äº¤.

å¯¹äºæ¯ä¸€æ¡å°„çº¿(åƒç´ ),å¦‚æœå¯ä»¥,æˆ‘ä»¬å°†è¿”å›ä¸€ä¸ªè¡¨ç¤ºåˆ°ä¸‰è§’å½¢æœ€çŸ­è·ç¦»çš„æµ®ç‚¹å€¼,å¦åˆ™è¿”å›è¡¨ç¤ºæ— ç©·å¤§çš„ç‰¹æ®Šå€¼`float('inf')`.æˆ‘ä»¬ç°åœ¨ä¸ä¼šè¿”å›å“ªäº›ä¸‰è§’å½¢æ˜¯ç›¸äº¤çš„.

è¯·æ³¨æ„,åˆ°ä¸‰è§’å½¢çš„è·ç¦»ç‰¹æŒ‡**æ²¿xè½´çš„è·ç¦»**,è€Œä¸æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦».

### Exercise-å®Œæˆ`raytrace_mesh`
<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<span class="token token key atrule">Difficulty: ğŸ”´ğŸ”´ğŸ”´âšªâšª</span><br>
<span class="token token key atrule">Importance: ğŸ”µğŸ”µğŸ”µğŸ”µâšª</span><br>
ä½ åº”è¯¥èŠ±æœ€å¤š20-25åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.<br>
è¿™æ˜¯æˆ‘ä»¬ä¸€ç›´åœ¨æ„å»ºçš„ä¸»è¦å‡½æ•°,å¹¶ä¸”å®Œæˆä»–æ ‡å¿—ç€è¿™ä¸€èŠ‚æ ¸å¿ƒå†…å®¹çš„å®Œæˆ.ä»–æ¶‰åŠäº†å¤§é‡ä¸Šä¸€ä¸ªç»ƒä¹ ä¸­åº”è¯¥é‡å¤åˆ©ç”¨çš„ä»£ç .<br>
</div>

å’Œå…ˆå‰ä¸€æ ·å®Œæˆ`raytrace_mesh`,é‡å¡‘å¹¶å¯è§†åŒ–è¾“å‡º.ä½ çš„çš®å¡ä¸˜ä»¥(0,0,0)ä¸ºä¸­å¿ƒç‚¹,æ‰€ä»¥ä½ åº”è¯¥æŠŠä½ çš„å…‰çº¿å‡ºå‘ç‚¹ç§»åˆ°æ—è¾¹,è‡³å°‘`x=-2`æ¥å®Œæ•´çš„è§‚å¯Ÿä»–.

è¯·è®°ä½,`t.linalg.solve`(å’Œå¤§éƒ¨åˆ†æ‰¹æ“ä½œ)å¯ä»¥æ¥å—ä»¥æ‰¹å¤„ç†çš„æ–¹å¼æ¥å—å¤šä¸ªç»´åº¦.å…ˆå‰ä½ ä»…ä»…ç”¨`NR`(the number of rays, å…‰çº¿çš„æ•°é‡)è¡¨ç¤ºæ‰¹ç»´åº¦,ä½†æ˜¯ç°åœ¨ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨`(NR, NT)`(the number of rays and triangles, å…‰çº¿å’Œä¸‰è§’å½¢çš„æ•°é‡)ä½œä¸ºä½ çš„æ‰¹ç»´åº¦,æ‰€ä»¥ä½ å¯ä»¥ä¸€å£æ°”solveæ‰€æœ‰çš„å…‰çº¿å’Œä¸‰è§’å½¢.
```python
def raytrace_mesh(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangles: Float[Tensor, "ntriangles trianglePoints=3 dims=3"]
) -> Float[Tensor, "nrays"]:
    '''
    For each ray, return the distance to the closest intersecting triangle, or infinity.
    '''
    pass


num_pixels_y = 120
num_pixels_z = 120
y_limit = z_limit = 1

rays = make_rays_2d(num_pixels_y, num_pixels_z, y_limit, z_limit)
rays[:, 0] = t.tensor([-2, 0.0, 0.0])
dists = raytrace_mesh(rays, triangles)
intersects = t.isfinite(dists).view(num_pixels_y, num_pixels_z)
dists_square = dists.view(num_pixels_y, num_pixels_z)
img = t.stack([intersects, dists_square], dim=0)

fig = px.imshow(img, facet_col=0, origin="lower", color_continuous_scale="magma", width=1000)
fig.update_layout(coloraxis_showscale=False)
for i, text in enumerate(["Intersects", "Distance"]): 
    fig.layout.annotations[i]['text'] = text
fig.show()
```

<div style="background-color: #FFDDDD; padding: 10px; border-radius: 5px; margin-bottom: 10px">
<details>
    <summary style="margin-bottom: 3px">Solution</summary>
    <div style="background-color: #FFFFFF; border: 4px solid #9999FF;">

    def raytrace_mesh(
        rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
        triangles: Float[Tensor, "ntriangles trianglePoints=3 dims=3"]
    ) -> Float[Tensor, "nrays"]:
        '''
        For each ray, return the distance to the closest intersecting triangle, or infinity.
        '''
        # SOLUTION
        NR = rays.size(0)
        NT = triangles.size(0)

        # Each triangle is [[Ax, Ay, Az], [Bx, By, Bz], [Cx, Cy, Cz]]
        triangles = einops.repeat(triangles, "NT pts dims -> pts NR NT dims", NR=NR)
        A, B, C = triangles
        assert A.shape == (NR, NT, 3)

        # Each ray is [[Ox, Oy, Oz], [Dx, Dy, Dz]]
        rays = einops.repeat(rays, "NR pts dims -> pts NR NT dims", NT=NT)
        O, D = rays
        assert O.shape == (NR, NT, 3)

        # Define matrix on left hand side of equation
        mat: Float[Tensor, "NR NT 3 3"] = t.stack([- D, B - A, C - A], dim=-1)
        # Get boolean of where matrix is singular, and replace it with the identity in these positions
        dets: Float[Tensor, "NR NT"] = t.linalg.det(mat)
        is_singular = dets.abs() < 1e-8
        mat[is_singular] = t.eye(3)

        # Define vector on the right hand side of equation
        vec: Float[Tensor, "NR NT 3"] = O - A

        # Solve eqns (note, s is the distance along ray)
        sol: Float[Tensor, "NR NT 3"] = t.linalg.solve(mat, vec)
        s, u, v = sol.unbind(-1)

        # Get boolean of intersects, and use it to set distance to infinity wherever there is no intersection
        intersects = ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)
        s[~intersects] = float("inf") # t.inf

        # Get the minimum distance (over all triangles) for each ray
        return s.min(dim=-1).values

</div>
</details>
</div>
