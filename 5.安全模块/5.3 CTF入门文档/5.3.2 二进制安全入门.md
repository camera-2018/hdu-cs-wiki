# 5.3.2 二进制安全入门

Author:`z221x`

## 简介

二进制安全在 CTF 中常分为 pwn 和 reverse 两大方向。

pwn 主要研究漏洞的挖掘及其利用的手段，并利用漏洞攻击目标取得目标机器的权限。

reverse 主要研究软件破解，软件加固，计算机病毒等。

现实场景下，这两种方向通常界限比较模糊，统称的二进制安全主要研究漏洞挖掘，漏洞利用，软件加固，计算机病毒，游戏安全等。

## 入门材料

> HGAME Mini Reverse Pwn 入门材料
>
> Reverse:[逆向入门指南](https://www.notion.so/b92ca2bfaacf4e7c873882dff9dbf649)
>
> Pwn:[PWN 入门指北](https://ek1ng.oss-cn-hangzhou.aliyuncs.com/HGAME%20Mini%202022%20Pwn%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97.pdf)

## 学习二进制安全需要具备哪些基础？

- 扎实的 C 语言基础，目前现有的各种二进制分析工具通常都会把汇编代码重新反编译为 C 语言程序。
- 适当的软件开发经验，安全的基础是开发。
- 扎实的汇编语言基础，如果你了解过编译的过程，就会知道现在的编译型语言，如 C，C++，go，rust 等，他们的编译产物通常都是对应架构的二进制程序，而二进制程序是可以直接反汇编成汇编代码的，换句话说，理论上能看懂汇编，就能看懂一切计算机程序。

## 为了打好基础，我应该怎么学？

::: tip 📥
《C Primer Plus》（第六版中文版）（216MB）附件下载 <Download url="https://cdn.xyxsw.site/files/C%20Primer%20Plus%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf"/>
:::

- C 语言推荐阅读《C Primer Plus》，C 语言领域的圣经。二进制对 C 语言的最低要求：熟练地使用链表完成约瑟夫环问题。
- x86 汇编语言推荐阅读王爽的《汇编语言》，在本文编辑时已经出到了第四版。x86 是目前最常用的 CPU 架构之一，目前基本上所有的电脑，服务器都采用的 x86 架构。因此在初期的二进制学习中，学习 x86 汇编语言是没有什么问题的。x86 汇编语言历史比较悠久，从 Intel 公司的第一代处理器 8086 采用的 16 位 x86 汇编语言开始，已经逐步发展到现在的 32 位/64 位。王爽的《汇编语言》讲的就是 16 位 x86 汇编语言。可能有人会问，现在学 16 位汇编语言还有什么用吗？其实 x86 的基础命令，对汇编语言来说只是寄存器的命名有所不同，寄存器的宽度也由 16 位升到 32 位再到 64 位而已。比如在 16 位汇编中，加法命令是 `add ax,bx`（意思是 ax=ax+bx，ax 和 bx 都是 16bit 的寄存器），而到了 32 位汇编中是 `add eax,ebx`，64 位汇编中是 `add rax,rbx`。虽然这些语句翻译成字节码是有区别的，但对于汇编语言来说差别并不大，因此由 16 位汇编入门，简单易上手，后面扩展到 32/64 位也很容易，是非常合适的。
- Python 的基本语法，Python 之所以没有作为“基础”，是因为在二进制安全中，Python 由于其简单，开发周期短的特性，往往充当一个锦上添花的工具的角色，比如在做逆向工程领域的研究时，使用 Python 来编写一些加解密脚本要比使用 C 语言快速。感受一下：

```c
#include<stdio.h>
#include<string.h>
int main()
{
    char ch[]="hello world";
    for(int i=0;i<strlen(ch);i++)
    {
        putchar(ch[i]^0x33);
    }
}
```

```python
print("".join(chr(ord(i)^0x33) for i in "hello world"))
```

但从方便学习的角度考虑，学习 Python 还是非常有好处的，因此学有余力的同学可以多加学习一下这一强大的工具。

## 逆向工程指北🤔

逆向工程(Reverse)，这个方向就跟他的名字一样，我们做的都是与其他人相反的工作。拿c举例，一个正常运行在操作系统上的程序，会经历代码文件->预处理->编译->汇编->链接，这几个过程变成一个可以运行在计算机上的程序文件。而作为逆向工程就是通过程序文件->反汇编->反编译->代码文件。这便是逆向工程的核心，当然逆向工程接触的不止是c语言。大体上可以分成两类，一类是解释型语言，而另一类是编译型语言。解释型语言是通过编程语言自带的解释器运行，如python，java，js等等，编译型语言就是会将代码文件编译成可执行文件然后运行在计算机上如c，c++，go这些语言。但是无论解释型语言还是编译型语言逆向思路都是一致的，使用的逆向工具不同罢了。

所以这里就还要插一句，逆向这个方向的工具真的是又多又杂，同类型的工具可以有好几种，每个工具都会有自己的优缺点，以及你自己对于这款工具的适应程度，作为一个合格的逆向手，你一定要对使用工具有自己的总结。对于工具的使用一定要学会阅读官方文档，学会安装以及使用插件(非常重要)，甚至是去开发插件。对于常用工具的介绍可以去群文件的逆向工具里面查看。

再插一嘴，现如今chatgpt遍地走的时代，ai对于逆向的帮助是很大的，但是你在入门打基础的阶段尽量不要去过多的使用ai，都使用搜索引擎，多翻阅一些大佬的博客，逛一逛论坛吾爱破解，看雪这些。

## 技术栈😩

对于入门来讲技术栈就是非常的简单，可以按照这个顺序补充自己的知识。

- C语言
- 汇编语言
- 常见加密算法（AES，DES，SM4，各种数据摘要算法、tea系列，RC4，chacha20，RSA，ECC......）
- 其他常见语言（python，java等等）
- 基础的反逆向技术（反调试，简单的虚拟化，花指令......）

ok，有了这些你才算正式的逆向入门。切记C语言与汇编是基础，一定要将这部分学习完成，并且通过学习汇编语言了解计算机底层的逻辑比如寄存器，栈，堆等等。

## 算法逆向😎

逆向工程的其中一个重点就是对于算法的逆向，抛开常见的固定的加密算法除外，一些代码编写者自定义的算法也有很多，这个时候就需要你自己去判断这个算法是否可逆，如果可逆，如何写出他的逆代码。

### 可逆运算

在讲述这些运算之前，先要明确一个观点，计算机由于其自身存储数据能力的限制，所以对于数据大小是有限制的，比如你在C语言里面学习的int32可以储存从`-2147483648`到`2147483647`大小的数字，所以当计算机进行运算时都是要在一个有限域内进行运算。可能稍微有点一头雾水，那就去补充一点数论知识吧。

然后剩下的可逆运算就很简单了，就是加法、减法、异或等等这些。

#### 算术运算

加法的逆运算是减法,减法的逆运算是加法,这两个有限域对其的影响不大.

乘法的有限域逆运算就稍微有些特殊，你在可以整除的时候可以正常的使用除法，不会影响，但是当你不能整除时，就会稍微麻烦一些，你需要使用乘法逆元。

比如:

```Python
（42*37）mod 256 = 18
 (18*173)mod 256 = 42 
```

这里的137就是37的乘法逆元，在数域m内只有a与m互质时才有乘法逆元（如何求乘法逆元请自行搜索）。

除法就更加特殊，会涉及到更复杂的计算机处理浮点数的规则，大多数的算法里面都不会用到除法。

#### 位运算

异或运算

非运算

位运算不过多解释

#### 尝试

可以尝试简单逆向下列算法（不要忘记了执行顺序）

```Python
for(int i=0;i<32;i++)
{
     input[i]=input[i]*37;
     input[i]+=0x12;
     input[i]^=0x77;
}
//input[32]={0xc6,0x4b,0xf1,0x4b,0xc6,0x66,0x91,0xb3,0xc6,0xf1,0xd9,0x91,0x66,0xb3,0x0,0x2f,0x91,0x79,0x0,0xf1,0xc6,0x8f,0xd9,0x60,0xf1,0x0,0x91,0x66,0xc6,0x60,0xc6,0xf1}
```

### 固定的加密算法

加密算法可以大致分为对称加密与非对称加密，对称算法指的是在加密与解密时使用的是相同的密钥（AES，SM4，RC4，tea系列），非对称算法指的是在加密与解密时使用的是不同的密钥（RSA，ECC），对于固定的加密算法他们的解密算法也是相应的固定，只有极少数情况会出现对加密算法进行魔改的情况，但是大多数也是魔改的部分常量，不会修改本身的逻辑。所以这部分在逆向中主要需要你可以准确的的识别出来他是什么算法。（对称加密会用的更多些，而且网上都会有公开的代码，请自行学习哟）

### 线性方程组求解

这部分需要一些线性代数的知识，所以只去浅显讲一下

线性方程组顾名思义就是由多个线性方程组合起来，举个例子

```Python
x+y+z=7
2x+y-z=12
x*8+9*y+3*z=55
```

像这样三个变量三个的线性方程是可以求解的，但是变成三个变量两个的线性方程呢？就会出现多解的情况。

对于三个变量的方程组手动计算还是非常简单的，但是要是遇到48个变量呢？这个时候就需要计算机的帮助，python是逆向人是好帮手，python的z3-solver库以及numpy都支持线性方程组求解

z3-solver使用的是约束求解（z3-solver还有很多其他的用处，等待你慢慢发掘，什么？不知道，那还不去看看官方文档┑(￣Д ￣)┍）。

而numpy是利用线性代数里面的矩阵。

对于这部分等你学习了一部分大学课程之后会明白很多。

上述提到的算法在`hgame-mini`赛题里面都有涉猎，逆向等待你的AK（解出全部题目）(๑•̀ㅂ•́)و✧

## PWN⼊⻔指北

Author:`l0tus`

### 前⾔

PWN是⼀个⾮常硬核的⽅向，需要学的东西很多，也很难理解，但是这也是⼀个学习计算机底层实现的极佳途径，⽽且能很好地帮助你理解⼀些难懂的东西，⽐如C语⾔的指针、链表。

### PWN是什么

PWN指的是⼆进制漏洞挖掘和利⽤，很多时候与web类似，都是审计代码，找到漏洞，想办法进⾏攻击，从⽽控制系统或者拿到系统的权限。

### PWN能做什么

PWN能做的东西很多，⽐如最近⽶哈游的反外挂服务存在漏洞，如果你的室友是⼀个OP，那么你就有办法控制他的电脑，往他们电脑中塞⼊⼀些奇奇怪怪的东西；⼜或是安卓⼿机获取root权限，以及苹果⼿机的越狱，很多时候都是PWN⼿负责的范围。

### 怎么学PWN

#### 基础知识

⼆进制⽅向的基础知识基本⼀样，都是c语⾔和汇编语⾔，具体的学习推荐可以看逆向⼊⻔指北中的介绍 学习使⽤python进⾏基本攻击脚本编写，学习pwntools的基本使⽤。

#### 前置知识

1. 基本的程序逆向。毕竟我们叫做⼆进制漏洞挖掘和利⽤，和⼆进制⽂件打交道，程序逆向的技能是必不可少的（⾄少要会使⽤IDAPro等⼯具，教程可以参考逆向中的IDAPro教程）。

2. 基本的Linux操作。毕竟Windows⽤⼾占有量巨⼤，相对来说攻击价值更⾼，但是相对应的

Windows也有更加多样的内存保护措施，另外Windows闭源的特性也增加了代码审计的难度。相反，Linux的内存保护⽐较简单，同时很多组件开源，代码审计难度⽐较低，对于PWN学习来说⻔槛也相对更低。

#### PWN⼊⻔

以我⾃⼰的经验来看，PWN最开始的以实践⼊⻔会相对简单⼀点，在对做题有点感觉后，在去补⾜⼀些理论性的知识。⼀边刷题⼀边学习是很不错的⼀种学习⽅式，可以多写博客记录⾃⼰的学习过程以及⼼得。还有⽐较重要的⼀点就是以兴趣为导向，多折腾折腾写写有趣的代码。

教程或是内容值得学习的⽹站： [ctf-wiki](https://ctf-wiki.org/)

[探姬前辈⽂章中⽩夜学⻓编写的pwn部分](https://ctf.tj.cn/ctf_pwn/) [pwn-college](https://pwn.college/)

[CS-wiki](https://csdiy.wiki/)

协会学⻓们的博客：

[19级PWN神xiaoyu的博客](https://www.xi4oyu.top/) 20级PWN神chuj的博客（重构中 失联了） [21级PWN神hakuya的博客](https://blog.hakuya.moe) [22级PWNbabyl0tus的博客](https://l0tus.vip)

刷题⽹站：

[攻防世界](https://adworld.xctf.org.cn/)题⽬有难度划分，适合⼊⻔

[buuoj](https://buuoj.cn/)题⽬量⽐较⼤，⼀般是看到⼀道题后上buuoj找相关环境

[pwnable.tw](https://pwnable.tw)题⽬质量⽐较⾼