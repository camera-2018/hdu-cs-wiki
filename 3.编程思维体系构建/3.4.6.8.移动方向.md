# 8.ç§»åŠ¨æ–¹å‘

*ä¼ ç»Ÿçš„æ–‡æœ¬å†’é™©ä½¿ç”¨[æŒ‡å—é’ˆæ–¹å‘](https://en.wikipedia.org/wiki/Cardinal_direction)è¿›è¡Œå¯¼èˆªã€‚*

ä¾‹å¦‚ï¼Œæˆ‘ä»¬åœ¨ç¬¬ 6 ç« ä¸­ç»˜åˆ¶çš„åœ°å›¾ä¸Šï¼Œç©å®¶å¯èƒ½æƒ³**å‘ä¸œ**ç§»åŠ¨ï¼Œä»ç”°é‡ç§»åŠ¨åˆ°æ´ç©´ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™è¿æ¥**Cave**çš„é€šé“æ ‡ä¸Šâ€œeastâ€æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ã€‚

1. æˆ‘ä»¬å¯èƒ½ä»ç„¶æƒ³æŠŠè¿™æ®µé€šé“ç§°ä¸ºâ€œentranceâ€å’Œâ€œeastâ€ã€‚ä½†ç°åœ¨ï¼Œä¸€ä¸ªå¯¹è±¡åªèƒ½æœ‰ä¸€ä¸ªæ ‡ç­¾ã€‚
2. åœ¨æ›´å¤§çš„åœ°å›¾ä¸Šï¼Œå…·æœ‰æ›´å¤šçš„ä½ç½®å’Œé“è·¯ï¼Œæ ‡ç­¾â€œeastâ€å°†è¢«å®šä¹‰å¤šæ¬¡ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ ‡ç­¾åœ¨æˆ‘ä»¬çš„æ¸¸æˆä¸­æ˜¯å…¨çƒç‹¬ä¸€æ— äºŒçš„ï¼Œæ²¡æœ‰é‡å¤é¡¹ã€‚

::: warning ğŸ¤” æ€è€ƒé¢˜ï¼šä½ èƒ½å¦æƒ³å‡ºè§£å†³åŠæ³•ï¼Ÿ
:::

è¿™äº›é—®é¢˜åŒæ ·é€‚ç”¨äºå…¶ä»–å¯¹è±¡ï¼Œè€Œä¸ä»…ä»…æ˜¯é€šé“ã€‚

åœ¨æˆ‘ä»¬çš„å†’é™©ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€æšé“¶å¸å’Œä¸€æšé‡‘å¸ã€‚ä¸€æ–¹é¢ï¼Œå¦‚æœä¸æ¥å—åœ¨åªæœ‰ä¸€æšç¡¬å¸å­˜åœ¨çš„åœ°ç‚¹å¾—åˆ°ç¡¬å¸ï¼Œé‚£å°†æ˜¯æ„šè ¢çš„ã€‚

å¦ä¸€æ–¹é¢ï¼Œåœ¨ä¸¤ç§ç¡¬å¸éƒ½åœ¨åŒä¸€ä½ç½®å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œç©å®¶åº”è¯¥å¯ä»¥æœ‰ä¸¤ä¸ªæ‹¾å–é€‰æ‹©ã€‚

è¿™ç«‹å³å°†æˆ‘ä»¬å¸¦åˆ°äº†è§£æå™¨çš„ç¬¬ä¸‰ä¸ªé—®é¢˜ï¼š

1. ä¸€ä¸ªæ ‡ç­¾åªèƒ½æ˜¯ä¸€ä¸ªå•è¯;â€œsliver coinâ€è¿™æ˜¯ä¿©å•è¯ï¼Œä»–ä¸æ¥å—å•Š

æ‰€æœ‰ä¸‰ä¸ªé—®é¢˜éƒ½å°†åœ¨æœ¬ç« ä¸­è§£å†³ï¼Œä»é—®é¢˜#1 å¼€å§‹ã€‚å®ƒé€šè¿‡ä¸ºæ¯ä¸ªå¯¹è±¡æä¾›ä¸€ä¸ªæ ‡ç­¾åˆ—è¡¨æ¥è§£å†³ï¼Œè€Œä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ ‡ç­¾ã€‚

## object.h

```c
typedef struct object {
   const char    *description;
   const char   **tags;
   struct object *location;
   struct object *destination;
} OBJECT;

extern OBJECT objs[];

#define field      (objs + 0)
#define cave       (objs + 1)
#define silver     (objs + 2)
#define gold       (objs + 3)
#define guard      (objs + 4)
#define player     (objs + 5)
#define intoCave   (objs + 6)
#define exitCave   (objs + 7)
#define wallField  (objs + 8)
#define wallCave   (objs + 9)

#define endOfObjs  (objs + 10)
```

## object.c

```c
#include <stdio.h>
#include "object.h"

static const char *tags0[] = {"field", NULL};
static const char *tags1[] = {"cave", NULL};
static const char *tags2[] = {"silver", "coin", "silver coin", NULL};
static const char *tags3[] = {"gold", "coin", "gold coin", NULL};
static const char *tags4[] = {"guard", "burly guard", NULL};
static const char *tags5[] = {"yourself", NULL};
static const char *tags6[] = {"east", "entrance", NULL};
static const char *tags7[] = {"west", "exit", NULL};
static const char *tags8[] = {"west", "north", "south", "forest", NULL};
static const char *tags9[] = {"east", "north", "south", "rock", NULL};
//æˆ‘ä»¬ä¸å›ºå®šæ ‡ç­¾é•¿åº¦ï¼Œåœ¨ç»“æŸçš„æ—¶å€™ç”¨ NULL æ¥æ ‡è®°
OBJECT objs[] = {
   {"an open field"              , tags0, NULL , NULL  },
   {"a little cave"              , tags1, NULL , NULL  },
   {"a silver coin"              , tags2, field, NULL  },
   {"a gold coin"                , tags3, cave , NULL  },
   {"a burly guard"              , tags4, field, NULL  },
   {"yourself"                   , tags5, field, NULL  },
   {"a cave entrance to the east", tags6, field, cave  },
   {"an exit to the west"        , tags7, cave , field },
   {"dense forest all around"    , tags8, field, NULL  },
   {"solid rock all around"      , tags9, cave , NULL  }
   //æˆ‘ä»¬ç”¨ NULL æ¥é˜»ç»è¿›å…¥ä¸€ä¸ªä½ ä¸çŸ¥é“çš„åœ°æ–¹
};
```

å½“ç„¶ï¼Œè¦è®©è¿™ä¸ªæ”¹åŠ¨ç”Ÿæ•ˆï¼Œæˆ‘ä»¬è¿˜éœ€è¦è°ƒæ•´*noun.c*ä¸­çš„*objectHasTag*å‡½æ•°ã€‚

*åŒæ—¶ï¼Œæˆ‘ä»¬å°†è®©å‡½æ•° getVisible*å’Œ*getPossession* å‘ŠçŸ¥ç©å®¶ä»–å¿…é¡»æ›´å…·ä½“çš„é€‰æ‹©ä½ åˆ°åº•æ˜¯é“¶å¸è¿˜æ˜¯é‡‘å¸ï¼Œè€Œä¸æ˜¯éšæœºé€‰æ‹©ä»»ä½•ä¸€ä¸ªå¯¹è±¡ã€‚

## noun.h

```c
extern OBJECT *getVisible(const char *intention, const char *noun);
extern OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun);
```

## **noun.c**

```c
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "object.h"
#include "misc.h"

static bool objectHasTag(OBJECT *obj, const char *noun)
{
   if (noun != NULL && *noun != '\0')
   {
      const char **tag;
      for (tag = obj->tags; *tag != NULL; tag++)
      {
         if (strcmp(*tag, noun) == 0) return true;
      }//æ‰«æå¯¹è±¡çš„ tag åˆ—è¡¨
   }
   return false;
}

static OBJECT ambiguousNoun;//æˆ‘ä»¬éœ€è¦è¿™ç©æ„çš„åœ°å€å¸®åŠ©æˆ‘ä»¬æŠŠå®ƒå½“æˆä¸€ä¸ªè¿”å›å€¼

static OBJECT *getObject(const char *noun, OBJECT *from, DISTANCE maxDistance)
{
   OBJECT *obj, *res = NULL;
   for (obj = objs; obj < endOfObjs; obj++)
   {
      if (objectHasTag(obj, noun) && getDistance(from, obj) <= maxDistance)
      {
         res = res == NULL ? obj : &ambiguousNoun;//æ ‡ç­¾ä¸æ˜ç¡®çš„è§£å†³æ–¹æ¡ˆå“¦
      }
   }
   return res;
}

OBJECT *getVisible(const char *intention, const char *noun)
{
   OBJECT *obj = getObject(noun, player, distOverthere);
   if (obj == NULL)
   {
      if (getObject(noun, player, distNotHere) == NULL)
      {
         printf("I don't understand %s.\n", intention);
      }
      else
      {
         printf("You don't see any %s here.\n", noun);
      }
   }
   else if (obj == &ambiguousNoun)//æ¨¡ç³ŠåŒ¹é…
   {
      printf("Please be specific about which %s you mean.\n", noun);
      obj = NULL;
   }
   return obj;
}

OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun)
{
   OBJECT *obj = NULL;
   if (from == NULL)
   {
      printf("I don't understand who you want to %s.\n", verb);
   }
   else if ((obj = getObject(noun, from, distHeldContained)) == NULL)
   {
      if (getObject(noun, player, distNotHere) == NULL)
      {
         printf("I don't understand what you want to %s.\n", verb);
      }
      else if (from == player)
      {
         printf("You are not holding any %s.\n", noun);
      }
      else
      {
         printf("There appears to be no %s you can get from %s.\n",
                noun, from->description);
      }
   }
   else if (obj == &ambiguousNoun)//æ¨¡ç³ŠåŒ¹é…
   {
      printf("Please be specific about which %s you want to %s.\n",
             noun, verb);
      obj = NULL;
   }
   else if (obj == from)
   {
      printf("You should not be doing that to %s.\n", obj->description);
      obj = NULL;
   }
   return obj;
}
```

é—®é¢˜ #3 å¯ä»¥é€šè¿‡ä»å‡½æ•°*parseAndExecute*ä¸­åˆ é™¤ä¸€ä¸ª [ç©ºæ ¼](http://en.wikipedia.org/wiki/Space_(punctuation))å­—ç¬¦æ¥è§£å†³ï¼ˆä¸‹é¢çš„ç¬¬ 10 è¡Œï¼‰ã€‚è¿™ä¸ªè§£å†³æ–¹æ¡ˆè¿œéå®Œç¾ï¼ˆ'silver' å’Œ 'coin' ä¹‹é—´çš„åŒç©ºæ ¼æ˜¯æ‰“å’©çš„ï¼‰ï¼Œä½†ç›´åˆ°æˆ‘ä»¬åœ¨ç¬¬ 13 ç« ä¸­è®©è‡ªå·±æˆä¸ºä¸€ä¸ªæ›´å¥½çš„è§£æå™¨ä¹‹å‰ã€‚

## parsexec.c

```c
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "location.h"
#include "inventory.h"

bool parseAndExecute(char *input)
{
   char *verb = strtok(input, " \n");
   char *noun = strtok(NULL, "\n");
   if (verb != NULL)
   {
      if (strcmp(verb, "quit") == 0)
      {
         return false;
      }
      else if (strcmp(verb, "look") == 0)
      {
         executeLook(noun);
      }
      else if (strcmp(verb, "go") == 0)
      {
         executeGo(noun);
      }
      else if (strcmp(verb, "get") == 0)
      {
         executeGet(noun);
      }
      else if (strcmp(verb, "drop") == 0)
      {
         executeDrop(noun);
      }
      else if (strcmp(verb, "give") == 0)
      {
         executeGive(noun);
      }
      else if (strcmp(verb, "ask") == 0)
      {
         executeAsk(noun);
      }
      else if (strcmp(verb, "inventory") == 0)
      {
         executeInventory();
      }
      else
      {
         printf("I don't know how to '%s'.\n", verb);
      }
   }
   return true;
}
```

æ¨¡å—*main.c*ã€*inventory.c*ã€*location.c*ã€*move.c* å’Œ*misc.c*ä¿æŒä¸å˜

ç°åœ¨å¯¹è±¡æ•°ç»„ ( *object.c* ) å¼€å§‹åœ¨å¤šä¸ªç»´åº¦ä¸Šå¢é•¿ï¼ˆç‰¹åˆ«æ˜¯åœ¨å¼•å…¥å¤šä¸ªæ ‡ç­¾çš„æƒ…å†µä¸‹ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§ä½¿å…¶æ›´æ˜“äºç»´æŠ¤çš„æ–¹æ³•ã€‚

::: warning ğŸ¤” çŒœçŒœçœ‹è¯¥æ€ä¹ˆåŠï¼Ÿ
:::
