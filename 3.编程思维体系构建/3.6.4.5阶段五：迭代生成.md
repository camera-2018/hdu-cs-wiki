# é˜¶æ®µäº”ï¼šè¿­ä»£ç”Ÿæˆ

## å‰è¨€

åœ¨å†™ä¹˜æ³•è¡¨çš„æ—¶å€™ï¼Œä½ å¯èƒ½å†™è¿‡ç±»ä¼¼

```python
for i in [2, 3, 5, 7, 11, 13]: print(i)
```

è¿™æ ·çš„è¯­å¥ã€‚for in è¯­å¥ç†è§£èµ·æ¥å¾ˆç›´è§‚å½¢è±¡ï¼Œæ¯”èµ· C++ å’Œ java æ—©æœŸçš„

```c
for (int i = 0; i < n; i ++)
```

è¿™æ ·çš„è¯­å¥ï¼Œä¸çŸ¥é“ç®€æ´æ¸…æ™°åˆ°å“ªé‡Œå»äº†ã€‚

ä½†æ˜¯ï¼Œä½ æƒ³è¿‡ Python åœ¨å¤„ç† for in è¯­å¥çš„æ—¶å€™ï¼Œå…·ä½“å‘ç”Ÿäº†ä»€ä¹ˆå—ï¼Ÿä»€ä¹ˆæ ·çš„å¯¹è±¡å¯ä»¥è¢« for in æ¥æšä¸¾å‘¢ï¼Ÿ

## å®¹å™¨è¿­ä»£

å®¹å™¨è¿™ä¸ªæ¦‚å¿µéå¸¸å¥½ç†è§£ã€‚

åœ¨ Python ä¸­ä¸€åˆ‡çš†å¯¹è±¡ï¼Œå¯¹è±¡çš„æŠ½è±¡å°±æ˜¯ç±»ï¼Œè€Œå¯¹è±¡çš„é›†åˆå°±æ˜¯å®¹å™¨ã€‚

åˆ—è¡¨`list: [0, 1, 2]`ï¼Œå…ƒç»„`tuple: (0, 1, 2)`ï¼Œå­—å…¸`dict: {0:0, 1:1, 2:2}`ï¼Œé›†åˆ`set: set([0, 1, 2])`éƒ½æ˜¯å®¹å™¨ã€‚

å¯¹äºå®¹å™¨ï¼Œä½ å¯ä»¥å¾ˆç›´è§‚åœ°æƒ³è±¡æˆå¤šä¸ªå…ƒç´ åœ¨ä¸€èµ·çš„å•å…ƒï¼›è€Œä¸åŒå®¹å™¨çš„åŒºåˆ«ï¼Œæ­£æ˜¯åœ¨äºå†…éƒ¨æ•°æ®ç»“æ„çš„å®ç°æ–¹æ³•ã€‚

ç„¶åï¼Œä½ å°±å¯ä»¥é’ˆå¯¹ä¸åŒåœºæ™¯ï¼Œé€‰æ‹©ä¸åŒæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦çš„å®¹å™¨ã€‚æ‰€æœ‰çš„å®¹å™¨éƒ½æ˜¯å¯è¿­ä»£çš„ï¼ˆiterableï¼‰ã€‚

```python
iterator = iter(iterable)
    while True:
        elem = next(iterator)
        # do something
```

- é¦–å…ˆï¼Œåœ¨å¯è¿­ä»£å¯¹è±¡ä¸Šè°ƒç”¨å†…ç½® `iter` å‡½æ•°ä»¥åˆ›å»ºå¯¹åº”çš„<em>è¿­ä»£å™¨</em>ã€‚
- è¦è·å–åºåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåœ¨æ­¤è¿­ä»£å™¨ä¸Šè°ƒç”¨å†…ç½® `next` å‡½æ•°ã€‚

å¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ äº†ï¼Œæ€ä¹ˆåŠï¼Ÿ

æˆ‘ä»¬éœ€è¦å¯¹è¿™ç§å¼‚å¸¸è¿›è¡Œå¤„ç†ã€‚

æ€è€ƒé¢˜ï¼šä»€ä¹ˆæ˜¯å¼‚å¸¸å¤„ç†ï¼Œä¸ºä»€ä¹ˆè¦è¿›è¡Œå¼‚å¸¸å¤„ç†ï¼Ÿæœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ

å¤šæ¬¡è°ƒç”¨ `iter` å¯è¿­ä»£å¯¹è±¡æ¯æ¬¡éƒ½ä¼šè¿”å›ä¸€ä¸ªå…·æœ‰ä¸åŒçŠ¶æ€çš„æ–°è¿­ä»£å™¨

ä½ ä¹Ÿå¯ä»¥è°ƒç”¨ `iter` è¿­ä»£å™¨æœ¬èº«ï¼Œå®ƒåªä¼šè¿”å›ç›¸åŒçš„è¿­ä»£å™¨è€Œä¸æ”¹å˜å®ƒçš„çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼Œæ‚¨ä¸èƒ½ç›´æ¥åœ¨å¯è¿­ä»£å¯¹è±¡ä¸Šè°ƒç”¨ nextã€‚

```python
>>> lst = [1, 2, 3, 4]
>>> next(lst)             # Calling next on an iterable
TypeError: 'list' object is not an iterator
>>> list_iter = iter(lst) # Creates an iterator for the list
>>> list_iter
<list_iterator object ...>
>>> next(list_iter)       # Calling next on an iterator
1
>>> next(list_iter)       # Calling next on the same iterator
2
>>> next(iter(list_iter)) # Calling iter on an iterator returns itself
3
>>> list_iter2 = iter(lst)
>>> next(list_iter2)      # Second iterator has new state
1
>>> next(list_iter)       # First iterator is unaffected by second iterator
4
>>> next(list_iter)       # No elements left!
StopIteration
>>> lst                   # Original iterable is unaffected
[1, 2, 3, 4]
```

## è‹±è¯­ç»ƒä¹ ï¼Œå¯¹è¿­ä»£å™¨çš„ç±»æ¯”

<strong>Analogy</strong>: An iterable is like a book (one can flip through the pages) and an iterator for a book would be a bookmark (saves the position and can locate the next page). Calling `iter` on a book gives you a new bookmark independent of other bookmarks, but calling `iter` on a bookmark gives you the bookmark itself, without changing its position at all. Calling `next` on the bookmark moves it to the next page, but does not change the pages in the book. Calling `next` on the book wouldn't make sense semantically. We can also have multiple bookmarks, all independent of each other.

## ç”Ÿæˆå™¨ï¼šæ‡’äººè¿­ä»£å™¨!

```python
def test_iterator():
    show_memory_info('initing iterator')
    list_1 = [i for i in range(100000000)]
    show_memory_info('after iterator initiated')
    print(sum(list_1))
    show_memory_info('after sum called')

def test_generator():
    show_memory_info('initing generator')
    list_2 = (i for i in range(100000000))
    show_memory_info('after generator initiated')
    print(sum(list_2))
    show_memory_info('after sum called')

%time test_iterator()
%time test_generator()

########## è¾“å‡º ##########

initing iterator memory used: 48.9765625 MB
after iterator initiated memory used: 3920.30078125 MB
4999999950000000
after sum called memory used: 3920.3046875 MB
Wall time: 17 s
initing generator memory used: 50.359375 MB
after generator initiated memory used: 50.359375 MB
4999999950000000
after sum called memory used: 50.109375 MB
Wall time: 12.5 s
```

å£°æ˜ä¸€ä¸ªè¿­ä»£å™¨å¾ˆç®€å•ï¼Œ[i for i in range(100000000)]å°±å¯ä»¥ç”Ÿæˆä¸€ä¸ªåŒ…å«ä¸€äº¿å…ƒç´ çš„åˆ—è¡¨ã€‚æ¯ä¸ªå…ƒç´ åœ¨ç”Ÿæˆåéƒ½ä¼šä¿å­˜åˆ°å†…å­˜ä¸­ï¼Œä½ é€šè¿‡ä»£ç å¯ä»¥çœ‹åˆ°ï¼Œå®ƒä»¬å ç”¨äº†å·¨é‡çš„å†…å­˜ï¼Œå†…å­˜ä¸å¤Ÿçš„è¯å°±ä¼šå‡ºç° OOM é”™è¯¯ã€‚

::: warning ğŸ¤” äº†è§£ä¸‹ yieldï¼ˆï¼‰å‡½æ•°å§ï¼Œä»–å¯ä»¥è¿”å›ä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡ï¼Œè¯•è¯•çœ‹æ‡‚è¿™ä¸ª
:::

```python
>>> def gen_list(lst):
...     yield from lst
...
>>> g = gen_list([1, 2, 3, 4])
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3
>>> next(g)
4
>>> next(g)
StopIteration
```

## æ€è€ƒé¢˜ï¼špython ä¼šæ˜¾ç¤ºä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

```python
>>> s = [1, 2, 3, 4]
>>> t = iter(s)
>>> next(s)
______

>>> next(t)
______

>>> next(t)
______

>>> iter(s)
______

>>> next(iter(s))
______

>>> next(iter(t))
______

>>> next(iter(s))
______

>>> next(iter(t))
______

>>> next(t)
______
```

```python
>>> r = range(6)
>>> r_iter = iter(r)
>>> next(r_iter)
______

>>> [x + 1 for x in r]
______

>>> [x + 1 for x in r_iter]
______

>>> next(r_iter)
______

>>> list(range(-2, 4))   # Converts an iterable into a list
______
```

## ä»»åŠ¡

P10ï¼šå®ç° `count`ï¼Œå®ƒæ¥å—ä¸€ä¸ªè¿­ä»£å™¨ `t` å¹¶è¿”å›è¯¥å€¼ `x` å‡ºç°åœ¨çš„å‰ n ä¸ªå…ƒç´ ä¸­çš„æ¬¡æ•° `t`

```python
def count(t, n, x):
    """Return the number of times that x appears in the first n elements of iterator t.

    >>> s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])
    >>> count(s, 10, 9)
    3
    >>> s2 = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7])
    >>> count(s2, 3, 10)
    2
    >>> s = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5])
    >>> count(s, 1, 3)
    1
    >>> count(s, 4, 2)
    3
    >>> next(s)
    2
    >>> s2 = iter([4, 1, 6, 6, 7, 7, 8, 8, 2, 2, 2, 5])
    >>> count(s2, 6, 6)
    2
    """
    "*** YOUR CODE HERE ***"
```

P11:å®ç°ç”Ÿæˆå™¨å‡½æ•° `scale(it, multiplier)`ï¼Œå®ƒäº§ç”Ÿç»™å®šè¿­ä»£çš„å…ƒç´  `it`ï¼ŒæŒ‰ `multiplier`.

åŒæ—¶ä¹Ÿå¸Œæœ›ä½ å°è¯•ä½¿ç”¨ `yield from` è¯­å¥ç¼–å†™è¿™ä¸ªå‡½æ•°ï¼

```python
def scale(it, multiplier):
    """Yield elements of the iterable it scaled by a number multiplier.

    >>> m = scale(iter([1, 5, 2]), 5)
    >>> type(m)
    <class 'generator'>
    >>> list(m)
    [5, 25, 10]
    >>> # generators allow us to represent infinite sequences!!!
    >>> def naturals():
    ...     i = 0
    ...     while True:
    ...         yield i
    ...         i += 1
    >>> m = scale(naturals(), 2)
    >>> [next(m) for _ in range(5)]
    [0, 2, 4, 6, 8]
    """
    "*** YOUR CODE HERE ***"
```
