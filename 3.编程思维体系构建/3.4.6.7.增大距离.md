# 7.å¢å¤§è·ç¦»

*ä¸€ä¸ªå…¸å‹çš„å†’é™©åŒ…å«è®¸å¤šè°œé¢˜ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œ[Infocom](https://en.wikipedia.org/wiki/Infocom)çš„å†’é™©å¾ˆéš¾å®Œæˆã€‚è§£å†³æ¯ä¸ªéš¾é¢˜å¯èƒ½éœ€è¦æ•°å‘¨ç”šè‡³æ•°æœˆçš„åå¤è¯•éªŒã€‚*

*å½“ç©å®¶æ“çºµè§’è‰²å¤±è´¥åï¼Œå¦‚æœåªæ˜¯è¿”å›â€œä½ ä¸èƒ½è¿™ä¹ˆæ“ä½œâ€æ¥å›åº”ç©å®¶ï¼Œä¼šå¾ˆ ntï¼Œå¾ˆæ²¡æ„æ€ã€‚*

*å®ƒå¿½ç•¥äº†ç”µè„‘æ¸¸æˆçš„ä¸€ä¸ªé‡è¦æ–¹é¢ï¼Œè€Œè¿™ä¹Ÿæ˜¯ç”Ÿæ´»æœ¬èº«çš„ä¸€éƒ¨åˆ†ï¼šç©å®¶å¿…é¡»ä»é”™è¯¯ä¸­å¸å–æ•™è®­ã€‚*

å½“ä½ çš„æ¸¸æˆåå¤è¾“å…¥ä¸œè¥¿éƒ½æ˜¯ï¼Œä½ ä¸èƒ½è¿™æ ·åšçš„æ—¶å€™ï¼Œä¼šæ˜¾å¾—å¾ˆæ— èŠçš„ã€‚

*å†’é™©æ¸¸æˆè‡³å°‘åº”è¯¥åšçš„æ˜¯è§£é‡Šä¸ºä»€ä¹ˆç©å®¶çš„å‘½ä»¤æ— æ³•å®Œæˆï¼šâ€œä½ ä¸èƒ½è¿™æ ·åšï¼Œå› ä¸º......â€è¿™æœ‰åŠ©äºä½¿è™šæ‹Ÿä¸–ç•Œæ›´å…·è¯´æœåŠ›ï¼Œæ•…äº‹æ›´å¯ä¿¡ï¼Œæ¸¸æˆæ›´æœ‰è¶£ã€‚*

æˆ‘ä»¬å·²ç»ä»˜å‡ºäº†ç›¸å½“å¤§çš„åŠªåŠ›è®©æ¸¸æˆè§£é‡Š**ä¸ºä»€ä¹ˆ**æŸäº›å‘½ä»¤æ˜¯æ— æ•ˆçš„ã€‚åªéœ€çœ‹çœ‹*åè¯.cï¼Œinventory.cï¼Œlocation.c*ï¼Œ*move.c*ä¸­çš„è®¸å¤š*printf*è°ƒç”¨ã€‚ä½†éšç€æ¸¸æˆå˜å¾—è¶Šæ¥è¶Šå¤æ‚ï¼Œè¿™æ­£æˆä¸ºä¸€ä¸ªç›¸å½“å¤§çš„è´Ÿæ‹…ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§æ›´ç»“æ„åŒ–çš„æ–¹æ³•æ¥æ£€æµ‹å’Œå¤„ç†é”™è¯¯æƒ…å†µã€‚è¿™å°±æ˜¯æˆ‘ä»¬åœ¨æœ¬ç« ä¸­å°†è¦è®¨è®ºçš„å†…å®¹ã€‚

å¤§å¤šæ•°å‘½ä»¤å¯¹ä¸€ä¸ªæˆ–å¤šä¸ªå¯¹è±¡è¿›è¡Œæ“ä½œï¼Œä¾‹å¦‚ï¼š

- ç©å®¶æ‹¿èµ·ä¸€ä»¶ç‰©å“ï¼Œç„¶åæŠŠå®ƒäº¤ç»™å¦ä¸€ä¸ª NPCã€‚
- ç©å®¶æ²¿ç€ä¸€æ¡é€šé“åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚

é¦–å…ˆè¦æ£€æŸ¥çš„ï¼ˆåœ¨[è§£æå™¨](http://en.wikipedia.org/wiki/Parsing)æ•è·æ£€æµ‹æ˜¯å¦ä¼šæœ‰æ˜æ˜¾[æ‹¼å†™é”™è¯¯](http://en.wikipedia.org/wiki/Typographical_error)ä¹‹åï¼‰æ˜¯è¿™äº›å¯¹è±¡**æ˜¯å¦å­˜åœ¨**;

å¤±è´¥åº”è¯¥å¯¼è‡´ç±»ä¼¼â€œè¿™é‡Œæ²¡æœ‰...â€œæˆ–â€ä½ çœ‹ä¸åˆ°ä»»ä½•ä¸œè¥¿...â€ç­‰æ–‡å­—å‡ºç°ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªé€šç”¨å‡½æ•°ï¼Œæ¯ä¸ªå‘½ä»¤éƒ½å¯ä»¥ä½¿ç”¨å®ƒæ¥æ‰¾å‡ºç©å®¶æ˜¯å¦åœ¨å¯åŠçš„èŒƒå›´å†…ã€‚

ä½ å¯èƒ½è®¤ä¸ºæˆ‘ä»¬åªéœ€è¦åŒºåˆ†ä¸¤ç§æƒ…å†µï¼šå¯¹è±¡åœ¨è¿™é‡Œï¼Œæˆ–è€…å®ƒä¸åœ¨è¿™é‡Œã€‚

ä½†æ˜¯è®¸å¤šå‘½ä»¤éœ€è¦æ›´å¤šçš„æ¸å˜ï¼Œè€Œä¸ä»…ä»…æ˜¯â€œè¿™é‡Œâ€å’Œâ€œä¸åœ¨è¿™é‡Œâ€ã€‚ä¾‹å­ï¼š

- è¦ä½¿ç”¨æ­¦å™¨æˆ–å·¥å…·ï¼Œç©å®¶å¿…é¡»æŒæœ‰å®ƒ;ä»…ä»…åœ¨ç°åœºå­˜åœ¨æ˜¯ä¸å¤Ÿçš„ã€‚
- ä½ ä¸èƒ½æ”¾ä¸‹ä¸€ä¸ªä½ æ²¡æ‹¿èµ·æ¥çš„é“å…·ï¼Œä¹Ÿä¸èƒ½æ‹¿èµ·ä¸€ä¸ªå·²ç»æœ‰çš„ä¸œè¥¿
- å¦‚æœä½ è·Ÿå•†äººä¹°ä¸œè¥¿çš„æ—¶å€™ï¼Œä»–åº—é‡Œä¸œè¥¿ä½ ä¸èƒ½éšä¾¿æ‹¿

| distSelf          | å¯¹è±¡æ˜¯ç©å®¶                                                     | object == player                                                               |
| ----------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| distHeld          | ç©å®¶æŒæœ‰ç‰©ä½“                                                   | object->location == player                                                     |
| distHeldContained | ç©å®¶æ‹¿ç€å¦ä¸€ä¸ªåŒ…å«è¯¥ç‰©ä½“çš„ç‰©ä½“ï¼ˆä¾‹å¦‚è¢‹å­ï¼‰                     | object->location != NULL &&<br/>object->location->location == player           |
| distLocation      | å¯¹è±¡æ˜¯ç©å®¶çš„ä½ç½®                                               | object == player->location                                                     |
| distHere          | å¯¹è±¡ä½äºç©å®¶çš„ä½ç½®                                             | object->location == player->location                                           |
| distHereContained | ä¸€ä¸ªç‰©ä½“ï¼ˆNPC æˆ–â€œå®¹å™¨â€ï¼‰å­˜åœ¨äºç©å®¶çš„ä½ç½®ï¼Œæ­£åœ¨æ‹¿ç€å¦ä¸€ä¸ªç‰©ä½“ | object->location != NULL &&<br/>object->location->location == player->location |
| distOverthere     | å¯¹è±¡æ˜¯é™„è¿‘çš„ä½ç½®                                               | getPassage(player->location, object) != NULL                                   |

ç¬¬ä¸€ç§æƒ…å†µï¼ˆå¯¹è±¡æ˜¯ç©å®¶ï¼‰å¯èƒ½çœ‹èµ·æ¥å¾®ä¸è¶³é“ï¼Œä½†å®ƒä»ç„¶å¾ˆé‡è¦ã€‚ä¾‹å¦‚ï¼Œå‘½ä»¤â€œexamine yourselfâ€*ä¸åº”è¯¥*è¿”å›â€œè¿™é‡Œæ²¡æœ‰ä½ è‡ªå·±â€ã€‚

æˆ‘è¯•å›¾éµå¾ªä¸€ä¸ªé€»è¾‘é¡ºåºï¼šé™„è¿‘çš„äº‹ç‰©æœ€é«˜ä¼˜å…ˆçº§ï¼Œéšåä¼˜å…ˆçº§ä¼šå˜ä½ã€‚

| distNotHere       | å¯¹è±¡ä¸åœ¨è¿™é‡Œï¼ˆæˆ–çœ‹èµ·æ¥ï¼‰ä¸åœ¨è¿™é‡Œ |                |
| ----------------- | -------------------------------- | -------------- |
| distUnknownObject | è§£æå™¨æ— æ³•è¯†åˆ«è¾“å…¥çš„åè¯         | object == NULL |

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬æœ‰ä¸ƒç§ä¸åŒçš„â€œè¿™é‡Œâ€æ¡ˆä¾‹ï¼Œä½†åªæœ‰ä¸€ç§æ˜¯â€œä¸åœ¨è¿™é‡Œâ€ã€‚è¿™æ˜¯å› ä¸ºé€šå¸¸ï¼Œæ¸¸æˆåªéœ€è¦æä¾›æœ‰å…³ç©å®¶å¯ä»¥æ„ŸçŸ¥çš„äº‹ç‰©çš„ä¿¡æ¯ã€‚å¦‚æœå®ƒä¸åœ¨è¿™é‡Œï¼Œé‚£ä¹ˆå°±æ²¡ä»€ä¹ˆå¯è¯´çš„äº†ã€‚

åœ¨æœ€å·¦è¾¹çš„åˆ—ä¸­ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªæ¡ˆä¾‹æå‡ºäº†ä¸€ä¸ªç¬¦å·åç§°ã€‚æˆ‘ä»¬å°†åœ¨åä¸º **DISTANCE** çš„[æšä¸¾](http://en.wikipedia.org/wiki/Enumerated_type)ä¸­æ”¶é›†è¿™äº›åç§°ã€‚

```c
typedef enum {
   distSelf,
   distHeld,
   distHeldContained,
   distLocation,
   distHere,
   distHereContained,
   distOverthere,
   distNotHere,
   distUnknownObject
} DISTANCE;
```

::: warning ğŸ’¡ typedef ä»¥åŠæšä¸¾ç±» enum ä¹‹å‰æœ‰æ¥è§¦è¿‡å—ï¼Ÿæ²¡æœ‰æ¥è§¦è¿‡çš„è¯å°±å»å­¦ä¹ ä¸€ä¸‹å§ã€‚
:::

åœ¨æœ€å³è¾¹çš„åˆ—ä¸­ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªæƒ…å†µæå‡ºäº†ä¸€ä¸ªæ»¡è¶³æ¡ä»¶ã€‚é€šè¿‡ä¸€äº›é‡æ–°æ´—ç‰Œï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å°†å…¶è½¬æ¢ä¸ºè®¡ç®—å¯¹è±¡â€œè·ç¦»â€çš„å‡½æ•°ï¼ˆä»ç©å®¶çš„è§’åº¦æ¥çœ‹ï¼‰ï¼š

```c
DISTANCE getDistance(OBJECT *from, OBJECT *to)
{
   return to == NULL                               ? distUnknownObject :
          to == from                               ? distSelf :
          to->location == from                     ? distHeld :
          to == from->location                     ? distLocation :
          to->location == from->location           ? distHere :
          getPassage(from->location, to) != NULL   ? distOverthere :
          to->location == NULL                     ? distNotHere :
          to->location->location == from           ? distHeldContained :
          to->location->location == from->location ? distHereContained :
                                                     distNotHere;
}
```

::: warning ğŸ¤” æ€è€ƒé¢˜ï¼š
ä½ æ˜¯å¦æœ‰å…¶ä»–æ–¹æ³•å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Ÿ

æ³¨ï¼šè‡ªè¡Œå®éªŒå³å¯
:::

å°±è¿™æ ·ï¼æˆ‘ä»¬å¯ä»¥è°ƒç”¨æ­¤å‡½æ•°å¹¶å¯¹å…¶è¿”å›å€¼è¿›è¡Œæ¯”è¾ƒã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬åœ¨ noun*.c*ä¸­æœ‰ä»¥ä¸‹ä»£ç ï¼š

```c
else if (!(obj == player ||
           obj == player->location ||
           obj->location == player ||
           obj->location == player->location ||
           getPassage(player->location, obj) != NULL ||
           (obj->location != NULL &&
            (obj->location->location == player ||
             obj->location->location == player->location))))
```

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨é€‚å½“çš„è·ç¦»æ£€æŸ¥æ›¿æ¢æ¯ä¸ªå­æ¡ä»¶ï¼š

```c
else if (!(getDistance(player, obj) == distSelf ||
           getDistance(player, obj) == distLocation ||
           getDistance(player, obj) == distHeld ||
           getDistance(player, obj) == distHere ||
           getDistance(player, obj) == distOverthere ||
           getDistance(player, obj) == distHeldContained ||
           getDistance(player, obj) == distHereContained))
```

è¿™å¯ä»¥ç®€åŒ–ä¸ºï¼š

```c
else if (getDistance(player, obj) >= distNotHere)
```

::: warning ğŸ¤” å°è¯•ç†è§£ä¸€ä¸‹è¿™æ ·åšçš„æ„ä¹‰
:::

è¿™åªæ˜¯ä¸€ä¸ªä¾‹å­ï¼Œè®©ä½ å¯¹è¿™ä¸ªæ¦‚å¿µæœ‰æ‰€äº†è§£;æ‚¨å°†åœ¨ä¸‹é¢æ‰¾åˆ°*noun.c*çš„å®é™…å®ç°ï¼Œçœ‹èµ·æ¥ç•¥æœ‰ä¸åŒã€‚

æ˜¯æ—¶å€™æŠŠäº‹æƒ…è½å®åˆ°ä½äº†ã€‚æšä¸¾ *DISTANCE* å’Œå‡½æ•° *getDistance* çš„å®šä¹‰è¢«æ·»åŠ åˆ° *misc.h* å’Œ *misc.c* ä¸­ï¼Œå› ä¸ºæˆ‘ä»¬å°†åœ¨å¤šä¸ªæ¨¡å—ä¸­ä½¿ç”¨å®ƒä»¬ã€‚

## misc.h

```c
typedef enum {
   distSelf,
   distHeld,
   distHeldContained,
   distLocation,
   distHere,
   distHereContained,
   distOverthere,
   distNotHere,
   distUnknownObject
} DISTANCE;

extern bool isHolding(OBJECT *container, OBJECT *obj);
    //æ˜¯å¦æŒæœ‰ç‰©ä½“
extern OBJECT *getPassage(OBJECT *from, OBJECT *to);
    //è·å–é€šé“
extern DISTANCE getDistance(OBJECT *from, OBJECT *to);
    //è®¡ç®—è·ç¦»
extern OBJECT *actorHere(void);
extern int listObjectsAtLocation(OBJECT *location);
```

## misc.c

```c
#include <stdbool.h>
#include <stdio.h>
#include "object.h"
#include "misc.h"

bool isHolding(OBJECT *container, OBJECT *obj)
{
   return obj != NULL && obj->location == container;
}

OBJECT *getPassage(OBJECT *from, OBJECT *to)
{
   if (from != NULL && to != NULL)
   {
      OBJECT *obj;
      for (obj = objs; obj < endOfObjs; obj++)
      {
         if (isHolding(from, obj) && obj->destination == to)
         {
            return obj;
         }
      }
   }
   return NULL;
}

DISTANCE getDistance(OBJECT *from, OBJECT *to)
{
   return to == NULL                               ? distUnknownObject :
          to == from                               ? distSelf :
          isHolding(from, to)                      ? distHeld :
          isHolding(to, from)                      ? distLocation :
          isHolding(from->location, to)            ? distHere :
          isHolding(from, to->location)            ? distHeldContained :
          isHolding(from->location, to->location)  ? distHereContained :
          getPassage(from->location, to) != NULL   ? distOverthere :
                                                     distNotHere;
}

OBJECT *actorHere(void)
{
   OBJECT *obj;
   for (obj = objs; obj < endOfObjs; obj++)
   {
      if (isHolding(player->location, obj) && obj == guard)
      {
         return obj;
      }
   }
   return NULL;
}

int listObjectsAtLocation(OBJECT *location)
{
   int count = 0;
   OBJECT *obj;
   for (obj = objs; obj < endOfObjs; obj++)
   {
      if (obj != player && isHolding(location, obj))
      {
         if (count++ == 0)
         {
            printf("You see:\n");
         }
         printf("%s\n", obj->description);
      }
   }
   return count;
}
```

æ³¨æ„ï¼šisHolding è¿™ä¸ªå‡½æ•°ä¹‹åæˆ‘ä»¬å°†åœ¨å„ä¸ªåœ°æ–¹ä½¿ç”¨

## location.h

```c
extern void executeLook(const char *noun);
extern void executeGo(const char *noun);
```

åœ¨å‡½æ•° *executeGo* ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ£€æŸ¥è·ç¦»æ¥æ›¿æ¢å¤§å¤šæ•° *if* æ¡ä»¶ã€‚

## location.c

```c
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "object.h"
#include "misc.h"
#include "noun.h"

void executeLook(const char *noun)
{
   if (noun != NULL && strcmp(noun, "around") == 0)
   {
      printf("You are in %s.\n", player->location->description);
      listObjectsAtLocation(player->location);
   }
   else
   {
      printf("I don't understand what you want to see.\n");
   }
}

void executeGo(const char *noun)
{
   OBJECT *obj = getVisible("where you want to go", noun);
   switch (getDistance(player, obj))
   {
   case distOverthere:
      printf("OK.\n");
      player->location = obj;
      executeLook("around");
      break;
   case distNotHere:
      printf("You don't see any %s here.\n", noun);
      break;
   case distUnknownObject:
      // already handled by getVisible
      break;
   default:
      //ä¸Šè¿°æƒ…å†µå‡ä¸ºå‡ºç°
      if (obj->destination != NULL)
      {
         printf("OK.\n");
         player->location = obj->destination;
         executeLook("around");
      }
      else
      {
         printf("You can't get much closer than this.\n");
      }
   }
}
```

::: warning ğŸ¤” æ€è€ƒé¢˜ï¼šä½ èƒ½å¦ä¸º switch å‡½æ•°å¢åŠ æ›´å¤š case æ¥å®Œå–„åˆ¤æ–­æ¡ä»¶ï¼Ÿ
:::

å‡½æ•° *executeGet* ä¹Ÿæ˜¯å¦‚æ­¤ã€‚

## **inventory.h**

```c
extern void executeGet(const char *noun);
extern void executeDrop(const char *noun);
extern void executeAsk(const char *noun);
extern void executeGive(const char *noun);
extern void executeInventory(void);
```

## **inventory.c**

```c
#include <stdbool.h>
#include <stdio.h>
#include "object.h"
#include "misc.h"
#include "noun.h"
#include "move.h"

void executeGet(const char *noun)
{
   OBJECT *obj = getVisible("what you want to get", noun);
   switch (getDistance(player, obj))
   {
   case distSelf:
      printf("You should not be doing that to yourself.\n");
      break;
   case distHeld:
      printf("You already have %s.\n", obj->description);
      break;
   case distOverthere:
      printf("Too far away, move closer please.\n");
      break;
   case distUnknownObject:
      // already handled by getVisible
      break;
   default:
      if (obj->location == guard)
      {
         printf("You should ask %s nicely.\n", obj->location->description);
      }
      else
      {
         moveObject(obj, player);
      }
   }
}

void executeDrop(const char *noun)
{
   moveObject(getPossession(player, "drop", noun), player->location);
}

void executeAsk(const char *noun)
{
   moveObject(getPossession(actorHere(), "ask", noun), player);
}

void executeGive(const char *noun)
{
   moveObject(getPossession(player, "give", noun), actorHere());
}

void executeInventory(void)
{
   if (listObjectsAtLocation(player) == 0)
   {
      printf("You are empty-handed.\n");
   }
}
```

æœ€åï¼Œæˆ‘ä»¬å°†è°ƒæ•´ noun*.c*ä¸­çš„çº¦æŸã€‚æˆ‘ä»¬æ­£åœ¨å‘å‡½æ•°*getObject*æ·»åŠ ä¸¤ä¸ªå‚æ•°ï¼Œä»¥ä¾¿æ‰¾åˆ°ç‰¹å®šåè¯çš„åŒ¹é…é¡¹ï¼ŒåŒæ—¶å¿½ç•¥ä»»ä½•è¢«è®¤ä¸ºä¸å­˜åœ¨çš„å¯¹è±¡ã€‚è¿™å°†åœ¨ä¸‹ä¸€ç« ä¸­å¾—åˆ°çœŸæ­£çš„å›æŠ¥ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« ä¸­ä»‹ç»å…·æœ‰ç›¸åŒæ ‡ç­¾çš„ä¸åŒå¯¹è±¡ã€‚

## noun.h

```c
extern OBJECT *getVisibleï¼ˆconst char *intentionï¼Œ const char *nounï¼‰;
extern OBJECT *getPossessionï¼ˆOBJECT *fromï¼Œ const char *verbï¼Œ const char *nounï¼‰;
```

## noun.c

```c
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "object.h"
#include "misc.h"

static bool objectHasTag(OBJECT *obj, const char *noun)
{
   return noun != NULL && *noun != '\0' && strcmp(noun, obj->tag) == 0;
}

static OBJECT *getObject(const char *noun, OBJECT *from, DISTANCE maxDistance)
{
   OBJECT *obj, *res = NULL;
   for (obj = objs; obj < endOfObjs; obj++)
   {
      if (objectHasTag(obj, noun) && getDistance(from, obj) <= maxDistance)
          //åªè€ƒè™‘ä¸å¯¹è±¡è·ç¦»å°äºæˆ–ç­‰äºæœ€å¤§è·ç¦»çš„ç‰©ä½“
      {
         res = obj;
      }
   }
   return res;
}

OBJECT *getVisible(const char *intention, const char *noun)
{
   OBJECT *obj = getObject(noun, player, distOverthere);
   //ç©å®¶çœ‹ä¸åˆ°çš„è‡ªåŠ¨å¿½ç•¥
   if (obj == NULL)
   {
      if (getObject(noun, player, distNotHere) == NULL)
      {
         printf("I don't understand %s.\n", intention);
      }
      else
      {
         printf("You don't see any %s here.\n", noun);
      }
   }
   return obj;
}

OBJECT *getPossession(OBJECT *from, const char *verb, const char *noun)
{
   OBJECT *obj = NULL;
   if (from == NULL)
   {
      printf("I don't understand who you want to %s.\n", verb);
   }
   else if ((obj = getObject(noun, from, distHeldContained)) == NULL)
       //é™åˆ¶èŒƒå›´
   {
      if (getObject(noun, player, distNotHere) == NULL)
      {
         printf("I don't understand what you want to %s.\n", verb);
      }
      else if (from == player)
      {
         printf("You are not holding any %s.\n", noun);
      }
      else
      {
         printf("There appears to be no %s you can get from %s.\n",
                noun, from->description);
      }
   }
   else if (obj == from)
   {
      printf("You should not be doing that to %s.\n", obj->description);
      obj = NULL;
   }
   return obj;
}
```

::: warning ğŸ¤” æ€è€ƒé¢˜ï¼šä½ èƒ½ç†è§£ä»€ä¹ˆæ—¶å€™åŠ  constï¼Œä»€ä¹ˆæ—¶å€™ä¸ç”¨å—ï¼Ÿ
:::

åœ¨æœ¬ç« ä¸­ï¼Œ*è·ç¦»*çš„æ¦‚å¿µä¸»è¦ç”¨äºåœ¨æ¸¸æˆå¯ä»¥ç»™ç”¨æˆ·çš„ä¸åŒå“åº”ä¹‹é—´è¿›è¡Œé€‰æ‹©ã€‚ä½†æ˜¯ï¼Œè·ç¦»çš„å¥½å¤„å¹¶ä¸å±€é™äº**è¾“å‡º**ç«¯;å®ƒå¯ä»¥åŒæ ·å¾ˆå¥½åœ°ç”¨äºåœ¨**è¾“å…¥**ç«¯è¿›è¡Œæ”¹è¿›ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è·ç¦»æ¥æé«˜å¯¹ç”¨æˆ·è¾“å…¥çš„åè¯çš„è¯†åˆ«ã€‚

è¾“å‡ºæ ·ä¾‹

Welcome to Little Cave Adventure.
You are in an open field.
You see:
a silver coin
a burly guard
a cave entrance

--> go guard
You can't get much closer than this.

--> give silver
You are not holding any silver.

--> ask silver
There appears to be no silver you can get from a burly guard.

--> get silver
You pick up a silver coin.

--> get gold
You don't see any gold here.

--> give silver
You give a silver coin to a burly guard.

--> go cave
OK.
You are in a little cave.
You see:
a gold coin
an exit

--> get gold
You pick up a gold coin.

--> give gold
There is nobody here to give that to.

--> quit

Bye!
