### 面向对象编程（OOP）
Python 支持面向对象的编程风格，允许开发者通过类和对象来组织代码。
简单来说，就是定义了一个类型，该类型包含一些成员、函数。根据类型创建的变量叫做类。

- 特别之处：Python 的类定义相比其他语言（如 Java 或 C++）更为简洁，不需要复杂的语法结构，使得代码更容易编写和理解。


```python
#创建了类“Car”
class Car:
    #“self”是一个指针，指向自己（当前对象）
    #该类具有成员brand、model、year
    #以下函数是类创建新的对象时自动调用的初始化函数，需要传入对应的参数
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year

    #定义了一个函数，用于打印当前对象的全部信息
    def display_info(self):
        return f"{self.year} {self.brand} {self.model}"

# 创建 Car 类的实例，该对象名为my_car
my_car = Car("Tesla", "Model S", 2024)

# 调用类函数常常使用“.”
print(my_car.display_info())
```

### 类的继承
Python支持类的继承，允许一个类继承另一个类的方法和属性。
多重继承允许一个类继承多个父类。


```python
class Animal:   #本例中承担“基类”的角色
    def speak(self):
        print("Animal speaks")

class Mammal(Animal):   #继承自Animal
    def walk(self): 
        print("Mammal walks")

class Cute:     #本例中承担“基类2”的角色
    def kiss(self):
        print("kiss you")
        
class Dog(Mammal,Cute):     #同时继承了Mammal和Cute,多重继承
    def wag_tail(self):
        print("Dog wags tail")

doggie=Dog()
doggie.speak()
doggie.wag_tail()
doggie.walk()
doggie.kiss()
```

### 特殊类
1. 抽象基类（Abstract Base Classes, ABCs）：用于创建其他类必须继承的抽象类，主要是为了定义通用的API。抽象方法定义在抽象基类中，使用@abstractmethod装饰器标记。子类必须实现抽象方法才能被实例化。
2. 枚举类：用于定义常量集合的类。使用Enum类来创建它们。


```python
#抽象类
from abc import ABC, abstractmethod

class Shape(ABC):   #抽象类Shape继承自模块abc里面的抽象基类ABC
    @abstractmethod     #表明函数“area”是抽象方法
    def area(self):
        pass    #无实际意义，占位

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):     #实现了area函数，允许被实例化
        return 3.14 * self.radius ** 2

# 使用 Circle 类
circle = Circle(5)
circle.area()

```


```python
#枚举类
from enum import Enum

class Color(Enum):  #枚举类Color继承自模块enum中的Enum类
    RED = 1
    GREEN = 2
    BLUE = 3

#枚举的访问方式
print(Color.RED)  
print(Color.RED.name) 
print(Color.RED.value)

```

### 类的方法
1. 实例方法：类的普通方法，它们的第一个参数总是self，表示类实例本身。实例方法可以访问和修改对象的状态。（见例子：Car）
2. 特殊方法：由双下划线包围的方法（如 __init__、__str__ 等），用于提供对类的内建操作的支持，比如迭代、运算符重载、访问属性等。
3. 类方法：用`@classmethod`装饰器标记的，它们的第一个参数是cls，代表类本身。类方法可以访问和修改类状态。
4. 静态方法：用`@staticmethod`装饰器标记的，不接受self或cls参数。这种方法既不访问实例状态也不访问类状态，它们是一种与类紧密联系的普通函数。
5. 抽象方法：定义在抽象基类中，使用`@abstractmethod`装饰器标记。子类必须实现抽象方法才能被实例化。（见例子：Circle）


```python
#特殊方法
class Book:
    def __init__(self, title):
        self.title = title

    def __str__(self):  #将这个
        return f"Book: {self.title}"

name=Book("Dream")
print(name)
```


```python
#类方法
class Employee:
    company = "XYZ Corp"

    @classmethod    #表明函数“display_company“是类方法，需要传入类本身
    def display_company(cls):
        print(f"Company: {cls.company}")

Employee.display_company()
```


```python
#静态方法
class Math:
    @staticmethod   #表明函数“add”是静态方法，不接受“self”和“cls”，基本上就是普通函数
    def add(x, y):
        return x + y
    
Math.add(3,5)
```

### 多线程
多线程类似于同时执行多个不同程序，使用线程可以把占据长时间的程序中的任务放到后台去处理、一定程度上提高程序运行速度
线程是一个相对而言高级的概念，本例简单展示，实际过程中需要考虑线程同步等问题

1. 创建线程：`threading.Thread(target=function,[args=,kwargs=])`，一般使用上述函数建立一个新线程，需要传入`function`（线程中运行的函数）、`args`（可选参数，必须是tuple类型）、`kwargs`（可选参数，必须是字典类型）
2. 开始线程：`start()`
3. 结束线程：`join()`，主线程将等待该线程结束




```python
import threading    #导入线程模块
import time     #用于sleep,体现线程的并行
def print_nums(threadname,size):
    for i in range(size):
        print(f"this is {threadname}",i)
        time.sleep(i) #线程之间的打印可以错开，来展现并行
        
thread1=threading.Thread(target=print_nums,args=("thread1",3))
thread2=threading.Thread(target=print_nums,args=("thread2",4))

thread1.start()     #几乎同时启动两个线程
thread2.start()

thread1.join()      #等待两个线程结束
thread2.join()
```
