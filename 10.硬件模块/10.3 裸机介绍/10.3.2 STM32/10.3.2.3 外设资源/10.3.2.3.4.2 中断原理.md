# 中断原理

> Author：余生

## 一、什么是中断？——先从“生活场景”讲起

想象你正在写作业（主程序），突然电话响了（外部事件），你必须暂停写作业，去接电话（处理事件），接完电话再回来继续写作业。

这个“暂停当前任务 → 处理突发事件 → 回到原来任务”的过程，就是中断（Interrupt）。

在STM32中：

- 写作业 = 主程序（main函数里的代码）
- 电话响了 = 某个外设发出了中断请求（比如按键按下、定时器溢出）
- 接电话 = 执行中断服务函数（ISR）
- 继续写作业 = 返回主程序继续执行

中断的本质：让CPU能“及时响应”外部或内部的重要事件，而不是傻等或不断轮询。

## 二、为什么要用中断？ vs 轮询（Polling）

| 对比项      | 轮询方式           | 中断方式               |
| ----------- | ------------------ | ---------------------- |
| CPU是否空转 | 是，一直在查状态   | 否，平时正常工作       |
| 响应速度    | 慢，取决于轮询频率 | 快，事件一发生立刻响应 |
| 效率        | 低，浪费CPU资源    | 高，CPU可做其他事      |
| 实时性      | 差                 | 强                     |

 结论：

轮询适合简单、不紧急的任务；

中断适合对实时性要求高的场景，如按键检测、串口收数据、定时任务等。

## 三、中断系统的三大核心组件

STM32的中断系统由三个关键部分组成：

1. 中断源（Interrupt Source）
2. EXTI（外部中断/事件控制器）
3. NVIC（嵌套向量中断控制器）

我们一个一个深入讲。

## 四、中断源（Interrupt Source）

中断源就是“谁发起了中断请求”。

### 常见中断源类型

| 类型       | 举例                     |
| ---------- | ------------------------ |
| 外部中断   | 按键按下、外部传感器信号 |
| 定时器中断 | TIM2溢出、PWM周期结束    |
| 串口中断   | USART1收到一个字节数据   |
| ADC中断    | 模数转换完成             |
| DMA中断    | 数据传输完成             |
| 系统异常   | 硬件错误、NMI、SysTick等 |

所有这些外设都可以配置为“产生中断”，一旦条件满足，就会向NVIC发出请求。

## 五、EXTI（External Interrupt/Event Controller）——外部中断控制器

### 5.1 什么是EXTI？

EXTI是STM32中专门用来管理外部引脚中断的模块。它就像一个“门口保安”，负责监听哪些GPIO引脚发生了电平变化，并决定是否上报给NVIC。

 注意：虽然叫“外部中断”，但它其实是芯片内部的一个控制器，专门处理来自GPIO引脚的中断请求。

### 5.2 EXTI的结构（以STM32F1为例）

STM32F1系列有 19条EXTI线路（Line 0~15 + 16~18）

- Line 0 ~ 15：对应每个GPIO引脚（PA0、PB0、PC0…）
- Line 16：PVD（可编程电压检测）
- Line 17：RTC闹钟
- Line 18：USB唤醒

关键点：

虽然有多个GPIO端口（A/B/C/D…），但每个编号的引脚共用一条EXTI线。

例如：PA0、PB0、PC0 都连接到 EXTI Line 0，但同一时间只能有一个能触发中断（需要软件选择）。

### 5.3 EXTI的工作流程

1. 配置GPIO为输入模式（如上拉输入）
2. 选择哪个引脚作为中断源（通过AFIO寄存器选择PA0还是PB0）
3. 设置触发方式：
   1. 上升沿触发（从低变高）
   2. 下降沿触发（从高变低）
   3. 双边沿触发（高低都触发）
4. 使能EXTI中断输出
5. EXTI检测到信号变化 → 向NVIC发送中断请求

### 5.4 EXTI的“中断” vs “事件”

EXTI不仅能产生中断，还能产生“事件”（Event）。

| 对比         | 中断（Interrupt） | 事件（Event）                  |
| ------------ | ----------------- | ------------------------------ |
| 是否进入CPU  | 是，会跳转到ISR   | 否，不进CPU                    |
| 是否需要NVIC | 是                | 否                             |
| 用途         | 需要CPU参与处理   | 触发其他外设（如启动ADC、DMA） |
| 延迟         | 有中断响应延迟    | 极快，硬件直连                 |

举例：

你可以设置“按键按下”产生一个事件，直接触发ADC开始采样，全程不需要CPU参与，效率极高！

## 六、NVIC（Nested Vectored Interrupt Controller）——嵌套向量中断控制器

这是整个中断系统的“大脑”和“调度中心”。

### 6.1 NVIC的功能

1. 接收所有中断请求（来自外设或EXTI）
2. 判断优先级，决定先响应哪个
3. 支持中断嵌套（高优先级可打断低优先级）
4. 自动保存/恢复上下文（CPU寄存器）
5. 跳转到正确的ISR

> NVIC是ARM Cortex-M内核的一部分，不是STM32厂商自己设计的，所有Cortex-M芯片都有NVIC。

### 6.2 中断优先级（Priority）

STM32的中断优先级分为 4位（F1系列），可以分成：

- 抢占优先级（Preemption Priority）：决定是否可以“打断”其他中断
- 子优先级（Subpriority）：决定多个中断同时发生时的执行顺序

#### 优先级分组（Priority Group）

由于只有4位，需要事先分配多少位给抢占，多少位给子优先级。这叫“优先级分组”。

| 分组模式 | 抢占位数 | 子优先级位数 | 最大组数        |
| -------- | -------- | ------------ | --------------- |
| Group 0  | 0位      | 4位          | 1组，16子       |
| Group 1  | 1位      | 3位          | 2组，8子        |
| Group 2  | 2位      | 2位          | 4组，4子 ✅ 常用 |
| Group 3  | 3位      | 1位          | 8组，2子        |
| Group 4  | 4位      | 0位          | 16组，无子      |

规则：

- 抢占优先级高的可以打断抢占优先级低的（嵌套）
- 抢占相同，子优先级高的先执行
- 抢占和子都相同，看中断号（越小越优先）

> 推荐使用 Group 2：4个抢占优先级 + 4个子优先级，够用且不易出错。

### 6.3 中断向量表（Interrupt Vector Table）

这是NVIC的“电话簿”，记录了每个中断对应的处理函数地址。

#### 特点

- 存放在Flash开头（地址 0x0000_0000）
- 每个中断占4字节，存的是函数指针
- 包括：
  - 异常（Exception）：复位、NMI、Hard Fault、SysTick等
  - 外设中断：TIM2_IRQn、USART1_IRQn、EXTI0_IRQn…

举例： 当你按下按键触发EXTI0中断，NVIC查表发现EXTI0_IRQn对应的函数是`EXTI0_IRQHandler`，于是跳过去执行。

### 6.4 NVIC的寄存器

| 寄存器                             | 功能                     |
| ---------------------------------- | ------------------------ |
| ISER（Set Enable Register）        | 使能中断                 |
| ICER（Clear Enable Register）      | 关闭中断                 |
| ISPR（Set Pending Register）       | 手动触发中断（软件中断） |
| ICPR（Clear Pending Register）     | 清除中断挂起状态         |
| IPR（Interrupt Priority Register） | 设置中断优先级           |

> 实际编程中我们用库函数（如`NVIC_EnableIRQ()`）操作，不用直接写寄存器。

## 七、中断的完整执行流程（从触发到返回）

我们以“按键触发EXTI0中断”为例，详细走一遍流程：

### 步骤1：事件发生

- 用户按下按键 → PA0引脚从高电平变为低电平（下降沿）

### 步骤2：EXTI检测

- EXTI Line 0检测到下降沿
- 触发条件满足 → 设置“挂起寄存器”（Pending Bit）

### 步骤3：发送请求给NVIC

- EXTI向NVIC发出中断请求（IRQ）

### 步骤4：NVIC判断是否响应

- 当前是否有更高优先级中断正在运行？
- 全局中断是否使能？（CPSR寄存器I位）
- 如果可以响应 → 进入响应阶段

### 步骤5：CPU响应中断（异常进入）

- 自动保存上下文（R0~R3, R12, LR, PC, xPSR）
- 读取中断向量表，跳转到`EXTI0_IRQHandler`

### 步骤6：执行中断服务函数（ISR）

```cpp
void EXTI0_IRQHandler(void) {
    if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
        // 处理按键逻辑：比如翻转LED
        LED_Toggle();
        // 清除中断标志位（重要！）
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}
```

### 步骤7：中断返回

- 执行`BX LR`指令
- CPU自动恢复之前保存的上下文
- 继续执行被中断的主程序

## 八、中断服务函数（ISR）编写注意事项

### 正确做法

- 函数名必须和启动文件中定义的一致（如`EXTI0_IRQHandler`）
- 尽量简短，不要做耗时操作（如延时、打印）
- 及时清除中断标志位（否则会反复进入中断）
- 可以设置标志位，让主程序去处理复杂逻辑

### 错误做法

```cpp
void EXTI0_IRQHandler(void) {
    Delay_ms(1000);  // 千万不要在这里延时！
    printf("Key pressed!\n"); // 打印太慢，影响实时性
}
```

### 推荐做法

```cpp
volatile uint8_t key_flag = 0;  // 全局标志
void EXTI0_IRQHandler(void) {
    if (EXTI_GetITStatus(EXTI_Line0)) {
        key_flag = 1;  // 只设标志
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}

// 主程序中处理
while (1) {
    if (key_flag) {
        key_flag = 0;
        LED_Toggle();
        printf("Key pressed!\n");
    }
}
```

## 九、中断嵌套（Nested Interrupt）

### 什么是嵌套？

高优先级中断可以打断正在执行的低优先级中断。

### 举例

- 中断A：优先级 2（抢占）
- 中断B：优先级 1（抢占） ← 更高

当CPU正在执行A的ISR时，B发生 → CPU会暂停A，先执行B，B执行完再回到A。

注意：

- 只有抢占优先级更高才能打断
- 子优先级不能打断

## 十、常见中断编号与命名（STM32F1参考）

| 中断名                   | 对应外设       | 说明                   |
| ------------------------ | -------------- | ---------------------- |
| NMI_IRQn                 | 非屏蔽中断     | 不受NVIC控制，必须响应 |
| HardFault_IRQn           | 硬件错误       | 如访问非法地址         |
| SysTick_IRQn             | 系统滴答定时器 | 操作系统常用           |
| WWDG_IRQn                | 窗口看门狗     |                        |
| EXTI0_IRQn ~ EXTI15_IRQn | 外部中断线0~15 |                        |
| TIM2_IRQn                | 定时器2        |                        |
| USART1_IRQn              | 串口1          |                        |
| ADC1_2_IRQn              | ADC1和ADC2     |                        |

> 所有中断名定义在 `stm32f10x.h` 文件中。

## 十一、软件配置流程（以HAL库为例）

```cpp
// 1. 使能时钟
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_AFIO_CLK_ENABLE();  // EXTI需要AFIO
// 2. 配置GPIO为输入
GPIO_InitTypeDef gpio;
gpio.Pin = GPIO_PIN_0;
gpio.Mode = GPIO_MODE_IT_FALLING;  // 下降沿中断
gpio.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &gpio);

// 3. 配置NVIC
HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);  // 抢占2，子0
HAL_NVIC_EnableIRQ(EXTI0_IRQn);

// 4. 编写回调函数（HAL库风格）
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    if (GPIO_Pin == GPIO_PIN_0) {
        LED_Toggle();
    }
}
```

## 十二、中断的优缺点总结

| 优点               | 缺点                   |
| ------------------ | ---------------------- |
| 响应快，实时性强   | 配置复杂               |
| 节省CPU资源        | 多中断时优先级管理复杂 |
| 支持嵌套，灵活性高 | ISR中不能调用阻塞函数  |
| 可实现事件驱动编程 | 调试困难（断点难打）   |

## 总结：一张图看懂STM32中断系统

```txt
[GPIO 引脚] 
    ↓ (电平变化)
[EXTI 控制器] —— 判断是否触发、是中断还是事件
    ↓ (中断请求)
[NVIC] —— 查优先级、查向量表、决定是否响应
    ↓
[CPU] —— 保存现场 → 跳转到 ISR → 执行 → 恢复现场
    ↓
[主程序继续运行]
```
