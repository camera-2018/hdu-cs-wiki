# 底层模块（计算机底层入门）

::: warning 施工中🚧
关于新版的编程模块，我们打算以`项目`的方式呈现，正在努力完善中，敬请期待！

关于本模块的旧版内容，你可以点击[这里](/2023旧版内容/旧版内容索引)查看。
:::

对于 2024 年的计算机世界，越来越多的人开始追求“高层次”的开发 —— 大模型应用、低代码平台、可视化工具、AI自动化。

但当各种“黑盒”工具充斥在你的开发之路上，你是否会好奇，**计算机的底层到底是怎么工作的？你使用你电脑时看似简单的每一步，背后蕴含着什么？**

如果你愿意把探索计算机底层当作一场兴趣驱动的旅程，你将收获的不只是技术，而是一种**对世界底层逻辑的理解**。

也许这份理解不会直接让你变得“会赚钱”，但它能带给你一种难得的安全感 ——

> 无论世界如何变化，你都知道 **计算机的本质**，而不仅仅是用它的“表面”。

## 章节题目解释

* **何为计算机底层？**

狭义上指硬件 + 系统软件（如汇编、操作系统） + 计算原理

广义上是理解“计算机是如何工作的”这件事

* **何为探索？**

不是要求马上学会写汇编、做硬件开发，而是了解底层知识的内容与意义，知道你要学什么、怎么学

## 行业背景

在 2024 年以前，**应用层开发**（前端、后端、移动端）是大多数计算机专业学生的就业方向

而**底层领域**看似“离大众很远”，但其实是撑起整个计算机世界的根基

* 为什么计算机能运行你的代码？
* 为什么操作系统能管理成千上万个程序？
* 为什么数据不会随便丢失，网络能稳定传输？

这些问题的答案，都离不开底层

## 步入正题 - 什么是“计算机底层”？

### 1️⃣ 计算机底层的构成

#### 硬件

* CPU、内存、硬盘、I/O设备
* 底层的逻辑电路、指令集、总线系统

#### 系统软件

* 汇编语言、机器码
* 操作系统（内核、驱动、进程管理）
* 编译器、链接器

#### 理论基础

* 计算机组成原理
* 操作系统原理
* 计算机体系结构
* 数字逻辑与电路

### 2️⃣ 举个例子 - 程序是怎么跑起来的？

#### 1. 明确需求

我们不写 Hello World，而是思考一个问题：

> 当你按下回车，Hello World 是怎么出现在屏幕上的？

#### 2. 程序的底层旅程

1. 你写的代码，经过**编译器**，被转换成**机器指令**
2. 编译后的程序被**加载到内存**
3. **CPU** 从内存取出指令，**逐条执行**
4. CPU通过**系统调用**，告诉操作系统：“我要往屏幕打印内容”
5. **操作系统** 找到对应的**驱动程序**，发送数据到**显示设备**
6. 你在屏幕上看到输出

#### 3.汇编的参与

如果我们不用 C/C++，而是用汇编呢？

```asm
mov rax, 1      ; 系统调用号：write
mov rdi, 1      ; 文件描述符：stdout
mov rsi, msg    ; 要输出的字符串地址
mov rdx, 13     ; 字符串长度
syscall         ; 执行系统调用
```

这就是**直接和系统沟通**的方式 —— 这也是程序员离“底层”最近的时刻（当然，你可能现在看这个还是一头雾水，不过随着学习的深入，你会慢慢揭开他神秘的面纱）

### 3️⃣ 底层的现实意义

* **理解性能瓶颈**

为什么内存访问比 CPU 寄存器慢？为什么多线程会有资源竞争？什么样的代码运行的更快？

举一个简单的C语言例子：

```c
int i, j;
int sum = 0;
int arr[2][2] = {1, 2, 3, 4};
for (i = 0, i < 2, i++){
    for (j = 0, j < 2, j++ ){
        sum += a[i][j]
    }
}
```

```c
int i, j;
int sum = 0;
int arr[2][2] = {1, 2, 3, 4};
for (j = 0, j < 2, i++){
    for (i = 0, i < 2, j++ ){
        sum += a[i][j]
    }
}
```

似乎两段代码并没有什么太大的区别，只是i和j的顺序换了，但是由于C语言中的数组是 **行主序存储**，内存布局：
`arr[0][0], arr[0][1], arr[1][0], arr[1][1]`

所以第一段是 按内存连续顺序访问，有更高的 缓存友好性，性能更好。

而第二段实际上是**列优先访问**，在 C语言里不符合内存顺序，可能导致 缓存不命中更频繁，性能略差。(当然在数据量小的情况下几乎感觉不到，此处只是举个简单的例子)

* **掌握调试和优化**

了解汇编和内存管理，让你调试比别人快一步

* **安全意识**

理解缓冲区溢出、内存泄漏、系统漏洞背后的本质

### 4️⃣ 底层的学习路径

1️⃣ **汇编 & 指令集**

了解计算机能识别的语言

2️⃣ **计算机组成原理**

知道硬件是怎么工作的

3️⃣ **操作系统原理**

理解操作系统是怎么管理硬件和程序的

4️⃣ **编译原理 & 链接原理**

知道你的代码是怎么变成机器能执行的程序

### 5️⃣ 从 Hello World 到 NEMU

你可以这样开始你的底层之旅：

* **写一个汇编 Hello World**
* **用 GDB 调试 C 程序，单步跟踪汇编指令**
* **尝试修改内存，理解堆栈的变化**
* **学习一个操作系统内核实验（如 NEMU ）**

### 6️⃣ 探索的乐趣

> 底层，不是让你永远写汇编
>
> 而是让你永远知道，程序在你看不到的地方，发生了什么

## 正式踏上底层学习之旅

别怕，别急，先去看看：

* 计算机是怎么执行你的第一行代码的
* 操作系统是怎么切换程序的
* 汇编是怎么控制硬件的

或许在你下次用 ChatGPT 调试的时候，你已经明白它为什么能懂代码了

## 结语

你不需要成为芯片工程师，但掌握一点底层知识，

> 会让你在浮躁的编程世界里，永远拥有一份底气

记住：每个程序员都曾对底层一头雾水，

> 但是你今天的困惑，正是林纳斯（Linux之父）、约翰·卡马克（游戏引擎之神）曾经的起点！
>
> —— 你即将踏上的，是成为‘真正的技术创造者’而非‘API调用员’的荣耀之路！”

虽然但是，可能你看到这里还是不太明白我们学底层到底要学些什么，说是学习计算机具体怎么工作，但是具体涉及什么呢？这个疑惑在笔者看来是很常见的，如果你是一位纯血新生，那你可能对上面提到的很多东西都不了解，甚至一无所知，但是这并没有关系，计算机底层所涉及的内容本身就是**广泛并且环环相扣**的，你需要做的是**不断的学习**一些前置知识，去拓宽你的视野，在这个过程中，你便会逐渐揭开底层的神秘面纱，理解魔幻的计算机世界。并且此文章仅是作为导论，既为导论，所以讲一些很硬核的东西并不是我们的目的（其实笔者鼠鼠菜的要命，你要鼠鼠讲硬核也讲不出来😭😭😭，而且之后的我们底层组的学习包够硬核的🤓），我们只是单纯的做一些引导，而且这不仅是导论的目地，更是我们之后组队学习的目的，底层组的优秀学长可以告诉你们如何去学，怎样学好，但是最后的执行者永远是你们自己（我们伟大的组长从不push）只要愿意坚持学习，成功的也一定会是你们。
鼠鼠讲了一大堆废话哈，然后接下来我们将逐步踏入底层的学习，首先从硬件的角度来了解计算机
