# 软件破解、软件加固

## 软件加壳、脱壳技术

壳是一种常见的软件保护技术，通过对前面基础工具的使用，我们很容易发现正常编译出来的程序逆向的难度并不高，只需按 IDA 的 F5 即可浏览程序的大部分逻辑。但加壳后的软件，会将主要逻辑 以一定的规律加密/压缩等，使其不可直接 F5 查看逻辑。

按壳的效果来分，主要分压缩壳和加密壳两种。压缩壳如 UPX，可以将程序体积较大的缩小。加密壳如 VMP，可以对程序起到非常大的防逆向作用，以目前的技术，对 VMP 加壳的程序几乎没有逆向的可能。

### 简单的 UPX 壳

UPX 是一个常见的压缩壳，通过该工具可以比较大的缩小二进制程序的体积，而不影响正常功能

UPX 壳的官网：[https://upx.github.io](https://upx.github.io)

加壳命令（示例）：

```c
upx -1 文件名
```

脱壳命令：

```c
upx -d 文件名
```

### ESP 定律脱壳法（本节来源于 ctf-wiki：[https://ctf-wiki.org/reverse/platform/windows/unpack/esp/](https://ctf-wiki.org/reverse/platform/windows/unpack/esp/)）

ESP 定律法是脱壳的利器，是应用频率最高的脱壳方法之一。

#### 要点

ESP 定律的原理在于利用程序中堆栈平衡来快速找到 OEP.

由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器状态压栈，如使用 `pushad`, 在解压结束后，会将之前的寄存器值出栈，如使用 `popad`. 因此在寄存器出栈时，往往程序代码被恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步操作，就很容易到达正确的 OEP 位置。

1. 程序刚载入开始 pushad/pushfd
2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点
3. 运行程序，触发断点
4. 删除硬件断点开始分析

#### 示例

示例程序可以点击此处下载：[2_esp.zip](https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/2_esp.zip)

还是上一篇的示例，入口一句 `pushad`, 我们按下 F8 执行 `pushad` 保存寄存器状态，我们可以在右边的寄存器窗口里发现 `ESP` 寄存器的值变为了红色，也即值发生了改变。

![](https://cdn.xyxsw.site/boxcnJdWqlHmhlvB471dIGT4GEh.png)

我们鼠标右击 `ESP` 寄存器的值，也就是图中的 `0019FF64`, 选择 `HW break[ESP]` 后，按下 `F9` 运行程序，程序会在触发断点时断下。如图来到了 `0040D3B0` 的位置。这里就是上一篇我们单步跟踪时到达的位置，剩余的就不再赘述。

## 软件加密常用算法

逆向中通常出现的加密算法包括 base64、TEA、AES、RC4、MD5、DES 等。

## 序列号生成与破解与反破解

早期软件序列号都是软件内部一套验证算法，本地进行验证序列号是否正确，或者本地校验格式再向服务器请求。这种软件的序列号破解只需找到内部验证算法，生成出一个合适的序列号即可，联网的软件就将联网屏蔽/做个假的服务器返回正确的信息等办法。如何找到验证算法是关键，此处就需要一定的逆向基础。现有的 CTF 逆向题基本都是从序列号破解的角度抽象出来的。

如今的很多软件都已不再采用序列号机制，比如 steam 游戏，或者序列号的生成是单向不可逆的，此时就对软件的破解造成了一定的困难
