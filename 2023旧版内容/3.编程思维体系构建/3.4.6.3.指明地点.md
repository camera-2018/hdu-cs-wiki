# 3.æŒ‡æ˜åœ°ç‚¹

::: warning <font size=5>æŸç§æå…¶ç³Ÿç³•çš„ç¼–ç¨‹ä¹ æƒ¯</font>
<font size=5><strong>Copy-paste</strong></font>

æˆ‘ä»¬å¾ˆå¤šåŒå­¦åœ¨ç¼–ç¨‹çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå†™å‡ºä¸€å¤§å †é‡å¤æ€§å¾ˆå¼ºçš„ä»£ç ï¼Œåœ¨æœ€è¿‘çœ‹çš„ pa ä¸­ï¼Œä¸¾äº†è¿™æ ·ä¸€ä¸ªä¾‹å­ï¼Œä½ ä¸éœ€è¦çœ‹æ‡‚åªéœ€è¦æ„Ÿå—åˆ°å°±å¯ï¼š
:::

```c
if (strcmp(s, "$0") == 0)
  return cpu.gpr[0]._64;
else if (strcmp(s, "ra") == 0)
  return cpu.gpr[1]._64;
else if (strcmp(s, "sp") == 0)
  return cpu.gpr[2]._64;
else if (strcmp(s, "gp") == 0)
  return cpu.gpr[3]._64;
else if (strcmp(s, "tp") == 0)
  return cpu.gpr[4]._64;
else if (strcmp(s, "t0") == 0)
  return cpu.gpr[5]._64;
else if (strcmp(s, "t1") == 0)
  return cpu.gpr[6]._64;
else if (strcmp(s, "s2") == 0)
  return cpu.gpr[7]._64;
else if (strcmp(s, "s0") == 0)
  return cpu.gpr[8]._64;
else if (strcmp(s, "s1") == 0)
  return cpu.gpr[9]._64;
else if (strcmp(s, "a0") == 0)
  return cpu.gpr[10]._64;
else if (strcmp(s, "a1") == 0)
  return cpu.gpr[11]._64;
else if (strcmp(s, "a2") == 0)
  return cpu.gpr[12]._64;
else if (strcmp(s, "a3") == 0)
  return cpu.gpr[13]._64;
else if (strcmp(s, "a4") == 0)
  return cpu.gpr[14]._64;
else if (strcmp(s, "a5") == 0)
  return cpu.gpr[15]._64;
else if (strcmp(s, "a6") == 0)
  return cpu.gpr[16]._64;
else if (strcmp(s, "a7") == 0)
  return cpu.gpr[17]._64;
else if (strcmp(s, "s2") == 0)
  return cpu.gpr[18]._64;
else if (strcmp(s, "s3") == 0)
  return cpu.gpr[19]._64;
else if (strcmp(s, "s4") == 0)
  return cpu.gpr[20]._64;
else if (strcmp(s, "s5") == 0)
  return cpu.gpr[21]._64;
else if (strcmp(s, "s6") == 0)
  return cpu.gpr[22]._64;
else if (strcmp(s, "s7") == 0)
  return cpu.gpr[23]._64;
else if (strcmp(s, "s8") == 0)
  return cpu.gpr[24]._64;
else if (strcmp(s, "s8") == 0)
  return cpu.gpr[25]._64;
else if (strcmp(s, "s10") == 0)
  return cpu.gpr[26]._64;
else if (strcmp(s, "t2") == 0)
  return cpu.gpr[27]._64;
else if (strcmp(s, "t3") == 0)
  return cpu.gpr[28]._64;
else if (strcmp(s, "t4") == 0)
  return cpu.gpr[29]._64;
else if (strcmp(s, "t5") == 0)
  return cpu.gpr[30]._64;
else if (strcmp(s, "t5") == 0)
  return cpu.gpr[31]._64;
```

ä»¥ä¸‹æ˜¯æŸè®ºæ–‡çš„ä»£ç èŠ‚é€‰ï¼Œå¯ä»¥è¯´æ˜¯é”™è¯¯çš„èŒƒä¾‹ï¼š

```python
fx = torch.cat((xs[0], fs[0], xs[1], fs[1], xs[2], fs[2], xs[3], fs[3], xs[4], fs[4], xs[5], fs[5], xs[6], fs[6], xs[7], fs[7],
    xs[8], fs[8], xs[9], fs[9], xs[10], fs[10], xs[11], fs[11], xs[12], fs[12], xs[13], fs[13], xs[14], fs[14], xs[15], fs[15],
    xs[16], fs[16], xs[17], fs[17], xs[18], fs[18], xs[19], fs[19], xs[20], fs[20], xs[21], fs[21], xs[22], fs[22], xs[23], fs[23],
    xs[24], fs[24], xs[25], fs[25], xs[26], fs[26], xs[27], fs[27], xs[28], fs[28], xs[29], fs[29], xs[30], fs[30], xs[31], fs[31]), 1)
bx = torch.cat((xs[0], bs[0], xs[1], bs[1], xs[2], bs[2], xs[3], bs[3], xs[4], bs[4], xs[5], bs[5], xs[6], bs[6], xs[7], bs[7],
               xs[8], bs[8], xs[9], bs[9], xs[10], bs[10], xs[11], bs[11], xs[12], bs[12], xs[13], bs[13], xs[14], bs[14], xs[15], bs[15],
               xs[16], bs[16], xs[17], bs[17], xs[18], bs[18], xs[19], bs[19], xs[20], bs[20], xs[21], bs[21], xs[22], bs[22], xs[23], bs[23],
               xs[24], bs[24], xs[25], bs[25], xs[26], bs[26], xs[27], bs[27], xs[28], bs[28], xs[29], bs[29], xs[30], bs[30], xs[31], bs[31]), 1)
```

::: tip <font size=5>ä½ æƒ³æƒ³ï¼Œä½ é‡åˆ°è¿™ä¹ˆé•¿çš„ä»£ç ï¼Œä½ æ„¿æ„çœ‹ä»–å—ï¼Ÿ</font>

æ›´å¯æ€•çš„æ˜¯ï¼Œè¿™ç§ç¼–ç æ¨¡å¼å¯èƒ½ä¼šå¯¼è‡´æ„æƒ³ä¸åˆ°çš„ bugã€‚

å½“ä½ å‘ç°è¿™äº›ä»£ç æœ‰ bug çš„æ—¶å€™ï¼Œå™©æ¢¦æ‰åˆšåˆšå¼€å§‹ã€‚ä¹Ÿè®¸èŠ±äº†å¥½å‡ å¤©ä½ åˆè°ƒå‡ºä¸€ä¸ª bug çš„æ—¶å€™ï¼Œæ‰ä¼šæƒ³èµ·è¿™ä¸ª bug ä½ å¥½åƒä¹‹å‰åœ¨å“ªé‡Œè°ƒè¿‡ã€‚ä½ ä¹ŸçŸ¥é“ä»£ç é‡Œé¢è¿˜æœ‰ç±»ä¼¼çš„ bug, ä½†ä½ å·²ç»åˆ†è¾¨ä¸å‡ºå“ªäº›ä»£ç æ˜¯ä»€ä¹ˆæ—¶å€™ä»å“ªä¸ªåœ°æ–¹å¤åˆ¶è¿‡æ¥çš„äº†ã€‚

è¿™ç§ç³Ÿç³•çš„ç¼–ç¨‹ä¹ æƒ¯å« Copy-Paste, ç»è¿‡ä¸Šé¢çš„åˆ†æï¼Œç›¸ä¿¡ä½ ä¹Ÿå·²ç»é¢†ç•¥åˆ°å®ƒçš„å¯æ€•äº†ã€‚äº‹å®ä¸Šï¼Œ[å‘¨æºæºæ•™æˆ](https://cseweb.ucsd.edu/~yyzhou/)çš„å›¢é˜Ÿåœ¨ 2004 å¹´å°±è®¾è®¡äº†ä¸€æ¬¾å·¥å…· CP-Miner, æ¥è‡ªåŠ¨æ£€æµ‹æ“ä½œç³»ç»Ÿä»£ç ä¸­ç”±äº Copy-Paste é€ æˆçš„ bug. è¿™ä¸ªå·¥å…·è¿˜è®©å‘¨æºæºæ•™æˆæ”¶è·äº†ä¸€ç¯‡[ç³»ç»Ÿæ–¹å‘é¡¶çº§ä¼šè®® OSDI çš„è®ºæ–‡](http://pages.cs.wisc.edu/~shanlu/paper/OSDI04-CPMiner.pdf), è¿™ä¹Ÿæ˜¯å¥¹å½“æ—¶æ‰€åœ¨å­¦æ ¡ UIUC å²ä¸Šçš„ç¬¬ä¸€ç¯‡ç³»ç»Ÿæ–¹å‘çš„é¡¶çº§ä¼šè®®è®ºæ–‡ã€‚

åæ¥å‘¨æºæºæ•™æˆå‘ç°ï¼Œç›¸æ¯”äºæ“ä½œç³»ç»Ÿï¼Œåº”ç”¨ç¨‹åºçš„æºä»£ç ä¸­ Copy-Paste çš„ç°è±¡æ›´åŠ æ™®éã€‚äºæ˜¯å¥¹ä»¬å›¢é˜ŸæŠŠ CP-Miner çš„æŠ€æœ¯åº”ç”¨åˆ°åº”ç”¨ç¨‹åºçš„æºä»£ç ä¸­ï¼Œå¹¶åˆ›åŠäº† PatternInsight å…¬å¸ã€‚å¾ˆå¤š IT å…¬å¸çº·çº·è´­ä¹° PatternInsight çš„äº§å“ï¼Œå¹¶è¦æ±‚æä¾›ç›¸åº”çš„å®šåˆ¶æœåŠ¡ï¼Œç”šè‡³ PatternInsight å…¬å¸æœ€åè¿˜è¢« VMWare æ”¶è´­äº†ã€‚

è¿™ä¸ªæ•…äº‹æŠ˜å°„å‡ºï¼Œå¤§å…¬å¸ä¸­ç¨‹åºå‘˜çš„ç¼–ç¨‹ä¹ æƒ¯ä¹Ÿè®¸ä¸æ¯”ä½ å¥½å¤šå°‘ï¼Œä»–ä»¬ä¹Ÿä¼šå†™å‡º Copy-Paste è¿™ç§éš¾ä»¥ç»´æŠ¤çš„ä»£ç ã€‚ä½†åè¿‡æ¥è¯´ï¼Œé‡è§†ç¼–ç é£æ ¼è¿™äº›ä¼ä¸šçœ‹ä¸­çš„èƒ½åŠ›ï¼Œä½ ä»ç°åœ¨å°±å¯ä»¥å¼€å§‹åŸ¹å…»ã€‚
:::

*ä¼ ç»Ÿä¸Šï¼Œæ–‡æœ¬å†’é™©æ˜¯ç”±ï¼ˆè®¸å¤šï¼‰ä¸åŒä½ç½®ç»„æˆçš„è™šæ‹Ÿä¸–ç•Œã€‚è™½ç„¶è¿™ä¸æ˜¯å¿…éœ€çš„ï¼ˆä¸€äº›å†’é™©å‘ç”Ÿåœ¨ä¸€ä¸ªæˆ¿é—´é‡Œï¼ï¼‰ï¼Œä½†è¿™æ˜¯è§£é‡Š**æ•°æ®ç»“æ„**ä½¿ç”¨çš„å¥½æ–¹æ³•ã€‚*

æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ª[ç»“æ„](http://en.wikipedia.org/wiki/Struct_(C_programming_language))æ¥è¡¨ç¤ºä¸€ä¸ªä½ç½®ã€‚å®ƒåŒ…å«ä¸¤ä¸ªç®€å•çš„å±æ€§å¼€å§‹ï¼ˆç¨åå¯èƒ½ä¼šæœ‰æ›´å¤šçš„å±æ€§ï¼‰ã€‚

1. æè¿°ï¼šå¯¹ç‰©å“è¿›è¡Œæè¿°
2. æ ‡è®°ï¼šå…·ä½“çš„å¯¹å…¶è¿›è¡Œæ ‡è®°

```c
struct location { 
        const char *description; 
        const char *tag; 
     };
```

::: warning ğŸ¤” æ€è€ƒé¢˜ï¼š
  æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦ç”¨ç»“æ„ä½“æ¥ä¿å­˜ä½ç½®ï¼Ÿ

  è¿™æ ·å­åšæœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ

  const åˆæ˜¯ä»€ä¹ˆï¼Ÿ
:::

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªä½ç½®æ•°ç»„ã€‚ç›®å‰ï¼Œæˆ‘ä»¬ä¿æŒå®ƒéå¸¸ç®€å•ï¼šåªæœ‰ä¸¤ä¸ªä½ç½®ã€‚

```c
struct location locs[2];
```

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨åˆå§‹å€¼è®¾å®šé¡¹ç«‹å³å¡«å……æ‰€æœ‰é™æ€æ•°æ®ã€‚

```c
struct location locs[2] = {
   {"an open field", "field"},
   {"a little cave", "cave"}
};
```

è®©æˆ‘ä»¬æŠŠå®ƒä»˜è¯¸å®è·µã€‚åœ¨ä¸Šä¸€ç« ï¼ˆ*parsexec.cï¼‰* çš„ä»£ç ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æ›´æ”¹äº†ç¬¬ 4ã€18 å’Œ 22 è¡Œï¼‰ã€‚

## <strong>parsexec.c</strong>

```c
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "location.h"

bool parseAndExecute(char *input)
{
   char *verb = strtok(input, " \n");
   char *noun = strtok(NULL, " \n");
   if (verb != NULL)
   {
      if (strcmp(verb, "quit") == 0)
      {
         return false;
      }
      else if (strcmp(verb, "look") == 0)
      {
         executeLook(noun);
      }
      else if (strcmp(verb, "go") == 0)
      {
         executeGo(noun);
      }
      else
      {
         printf("I don't know how to '%s'.\n", verb);
      }
   }
   return true;
}
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ªæ–°æ¨¡å—æ·»åŠ åˆ°é¡¹ç›®ä¸­

## <strong>location.h</strong>

```c
extern void executeLook(const char *noun);
extern void executeGo(const char *noun);
```

## <strong>location.c</strong>

```c
#include <stdio.h>
#include <string.h>

struct location {
   const char *description;
   const char *tag;
}
locs[] = {
   {"an open field", "field"},
   {"a little cave", "cave"}
};

#define numberOfLocations   (sizeof locs / sizeof *locs)
//æ¬¸ï¼Ÿè¿™ä¸ªæ˜¯å¹²å•¥å‘¢ï¼Ÿ
static unsigned locationOfPlayer = 0;

void executeLook(const char *noun)
{
   if (noun != NULL && strcmp(noun, "around") == 0)
   {
      printf("You are in %s.\n", locs[locationOfPlayer].description);
   }
   else
   {
      printf("I don't understand what you want to see.\n");
   }
}

void executeGo(const char *noun)
{
   unsigned i;
   for (i = 0; i < numberOfLocations; i++)
   {
      if (noun != NULL && strcmp(noun, locs[i].tag) == 0)
      {
         if (i == locationOfPlayer)
         {
            printf("You can't get much closer than this.\n");
         }
         else
         {
            printf("OK.\n");
            locationOfPlayer = i;
            executeLook("around");
         }
         return;
      }
   }
   printf("I don't understand where you want to go.\n");
}
```

åœ¨ C è¯­è¨€ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨å•ä¸ªè¯­å¥æ¥å®šä¹‰ç±»å‹ï¼ˆ*ç»“æ„ä½ç½®*ï¼‰ï¼Œå£°æ˜å˜é‡ï¼ˆ*locs*ï¼‰å¹¶ç”¨å…¶åˆå§‹å€¼å¡«å……å®ƒã€‚

æ€è€ƒé¢˜ï¼šå˜é‡*locs*æ˜¯[é™æ€åˆ†é…çš„](http://en.wikipedia.org/wiki/Static_memory_allocation)ï¼Œä»€ä¹ˆæ˜¯é™æ€åˆ†é…ï¼Ÿ

é™æ€åˆ†é…å’ŒåŠ¨æ€åˆ†é…æœ‰ä»€ä¹ˆä¸åŒä¹‹å¤„ï¼Ÿ

å¤æ‚æ€è€ƒé¢˜ï¼š13 è¡Œå®å®šä¹‰å¥½åƒå®ç°äº†ä¸€ä¸ªå‡½æ•°ï¼å¾ˆç¥å¥‡ï¼ä¸ºä»€ä¹ˆä¸ç”¨å‡½æ•°æ¥åšè¿™ä¸ªçŸ¥è¯†å‘¢ï¼Ÿ

æç¤ºï¼šè¿™ä¸ªé—®é¢˜æ¶‰åŠç¼–ç¨‹ä»ä»£ç åˆ°å¯æ‰§è¡Œæ–‡ä»¶çš„å››ä¸ªæ­¥éª¤ï¼Œå¸Œæœ›ä½ å¯ä»¥è®¤çœŸå­¦ä¹ å’Œæ€è€ƒï¼Œå¦‚æœä½ ç”¨ Linux å»å®Œæˆã€‚ä½ å¯ä»¥å°è¯•ç”¨ gcc é€æ­¥è¾“å‡ºç¼–è¯‘ç»“æœã€‚

æµ‹è¯•æ ·ä¾‹ï¼š

Welcome to Little Cave Adventure.
You are in an open field.

--> go cave
OK.
You are in a little cave.

--> go field
OK.
You are in an open field.

--> go field
You can't get much closer than this.

--> look around
You are in an open field.

--> go kitchen
I don't understand where you want to go.

--> quit

Bye!
